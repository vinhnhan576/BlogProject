{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst server_selection_1 = require(\"../sdam/server_selection\");\n\nconst utils_1 = require(\"../utils\");\n\nconst operation_1 = require(\"./operation\");\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction executeOperation(client, operation, callback) {\n  return (0, utils_1.maybeCallback)(() => executeOperationAsync(client, operation), callback);\n}\n\nexports.executeOperation = executeOperation;\n\nasync function executeOperationAsync(client, operation) {\n  var _a, _b;\n\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  if (client.topology == null) {\n    // Auto connect on operation\n    if (client.s.hasBeenClosed) {\n      throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n    }\n\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n\n    try {\n      await client.connect();\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n\n  const {\n    topology\n  } = client;\n\n  if (topology == null) {\n    throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n  }\n\n  if (topology.shouldCheckForSessionSupport()) {\n    await topology.selectServerAsync(read_preference_1.ReadPreference.primaryPreferred, {});\n  } // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n\n  let session = operation.session;\n  let owner;\n\n  if (topology.hasSessionSupport()) {\n    if (session == null) {\n      owner = Symbol();\n      session = client.startSession({\n        owner,\n        explicit: false\n      });\n    } else if (session.hasEnded) {\n      throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n    } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n      throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n    }\n  } else {\n    // no session support\n    if (session && session.explicit) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      throw new error_1.MongoCompatibilityError('Current topology does not support sessions');\n    } else if (session && !session.explicit) {\n      // We do not have to worry about ending the session because the server session has not been acquired yet\n      delete operation.options.session;\n      operation.clearSession();\n      session = undefined;\n    }\n  }\n\n  const readPreference = (_a = operation.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n  const inTransaction = !!(session === null || session === void 0 ? void 0 : session.inTransaction());\n\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);\n  }\n\n  if ((session === null || session === void 0 ? void 0 : session.isPinned) && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  let selector;\n\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)((_b = operation.server) === null || _b === void 0 ? void 0 : _b.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  const server = await topology.selectServerAsync(selector, {\n    session\n  });\n\n  if (session == null) {\n    // No session also means it is not retryable, early exit\n    return operation.executeAsync(server, undefined);\n  }\n\n  if (!operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n    // non-retryable operation, early exit\n    try {\n      return await operation.executeAsync(server, session);\n    } finally {\n      if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n        await session.endSession().catch(() => null);\n      }\n    }\n  }\n\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n  const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;\n\n  if (hasWriteAspect && willRetryWrite) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n\n  try {\n    return await operation.executeAsync(server, session);\n  } catch (operationError) {\n    if (willRetry && operationError instanceof error_1.MongoError) {\n      return await retryOperation(operation, operationError, {\n        session,\n        topology,\n        selector\n      });\n    }\n\n    throw operationError;\n  } finally {\n    if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n      await session.endSession().catch(() => null);\n    }\n  }\n}\n\nasync function retryOperation(operation, originalError, _ref) {\n  let {\n    session,\n    topology,\n    selector\n  } = _ref;\n  const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n\n  if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n    throw new error_1.MongoServerError({\n      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      originalError\n    });\n  }\n\n  if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n    throw originalError;\n  }\n\n  if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n    throw originalError;\n  }\n\n  if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n    // If we have a cursor and the initial command fails with a network error,\n    // we can retry it on another connection. So we need to check it back in, clear the\n    // pool for the service id, and retry again.\n    session.unpin({\n      force: true,\n      forceClear: true\n    });\n  } // select a new server, and attempt to retry the operation\n\n\n  const server = await topology.selectServerAsync(selector, {\n    session\n  });\n\n  if (isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n    throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n  }\n\n  try {\n    return await operation.executeAsync(server, session);\n  } catch (retryError) {\n    if (retryError instanceof error_1.MongoError && retryError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n      throw originalError;\n    }\n\n    throw retryError;\n  }\n}","map":{"version":3,"mappings":"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","names":["MMAPv1_RETRY_WRITES_ERROR_CODE","error_1","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","executeOperation","client","operation","callback","executeOperationAsync","exports","operation_1","topology","s","hasBeenClosed","options","Symbol","for","connect","shouldCheckForSessionSupport","selectServerAsync","read_preference_1","primaryPreferred","session","owner","hasSessionSupport","startSession","explicit","hasEnded","snapshotEnabled","capabilities","supportsSnapshotReads","clearSession","undefined","readPreference","_a","primary","inTransaction","equals","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","selector","hasAspect","MUST_SELECT_SAME_SERVER","server","_b","description","trySecondaryWrite","commonWireVersion","executeAsync","RETRYABLE","endSession","catch","willRetryRead","retryReads","canRetryRead","willRetryWrite","retryWrites","canRetryWrite","hasReadAspect","READ_OPERATION","hasWriteAspect","WRITE_OPERATION","willRetry","incrementTransactionNumber","operationError","retryOperation","originalError","isWriteOperation","isReadOperation","code","message","errmsg","CURSOR_CREATING","force","forceClear","retryError","hasErrorLabel","NoWritesPerformed"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\operations\\execute_operation.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport {\n  isRetryableReadError,\n  isRetryableWriteError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoNetworkError,\n  MongoNotConnectedError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { Callback, maybeCallback, supportsRetryableWrites } from '../utils';\nimport { AbstractOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> = TOperation extends AbstractOperation<infer K>\n  ? K\n  : never;\n\n/** @internal */\nexport interface ExecutionResult {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: Document;\n}\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param callback - The command result callback\n */\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T): Promise<TResult>;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, callback: Callback<TResult>): void;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void {\n  return maybeCallback(() => executeOperationAsync(client, operation), callback);\n}\n\nasync function executeOperationAsync<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T): Promise<TResult> {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  if (client.topology == null) {\n    // Auto connect on operation\n    if (client.s.hasBeenClosed) {\n      throw new MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n\n  const { topology } = client;\n  if (topology == null) {\n    throw new MongoRuntimeError('client.connect did not create a topology but also did not throw');\n  }\n\n  if (topology.shouldCheckForSessionSupport()) {\n    await topology.selectServerAsync(ReadPreference.primaryPreferred, {});\n  }\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner: symbol | undefined;\n  if (topology.hasSessionSupport()) {\n    if (session == null) {\n      owner = Symbol();\n      session = client.startSession({ owner, explicit: false });\n    } else if (session.hasEnded) {\n      throw new MongoExpiredSessionError('Use of expired sessions is not permitted');\n    } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n      throw new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n    }\n  } else {\n    // no session support\n    if (session && session.explicit) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      throw new MongoCompatibilityError('Current topology does not support sessions');\n    } else if (session && !session.explicit) {\n      // We do not have to worry about ending the session because the server session has not been acquired yet\n      delete operation.options.session;\n      operation.clearSession();\n      session = undefined;\n    }\n  }\n\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    throw new MongoTransactionError(\n      `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n    );\n  }\n\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  const server = await topology.selectServerAsync(selector, { session });\n\n  if (session == null) {\n    // No session also means it is not retryable, early exit\n    return operation.executeAsync(server, undefined);\n  }\n\n  if (!operation.hasAspect(Aspect.RETRYABLE)) {\n    // non-retryable operation, early exit\n    try {\n      return await operation.executeAsync(server, session);\n    } finally {\n      if (session?.owner != null && session.owner === owner) {\n        await session.endSession().catch(() => null);\n      }\n    }\n  }\n\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n\n  const willRetryWrite =\n    topology.s.options.retryWrites &&\n    !inTransaction &&\n    supportsRetryableWrites(server) &&\n    operation.canRetryWrite;\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const willRetry = (hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite);\n\n  if (hasWriteAspect && willRetryWrite) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n\n  try {\n    return await operation.executeAsync(server, session);\n  } catch (operationError) {\n    if (willRetry && operationError instanceof MongoError) {\n      return await retryOperation(operation, operationError, {\n        session,\n        topology,\n        selector\n      });\n    }\n    throw operationError;\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession().catch(() => null);\n    }\n  }\n}\n\n/** @internal */\ntype RetryOptions = {\n  session: ClientSession;\n  topology: Topology;\n  selector: ReadPreference | ServerSelector;\n};\n\nasync function retryOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(\n  operation: T,\n  originalError: MongoError,\n  { session, topology, selector }: RetryOptions\n): Promise<TResult> {\n  const isWriteOperation = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const isReadOperation = operation.hasAspect(Aspect.READ_OPERATION);\n\n  if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n    throw new MongoServerError({\n      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      originalError\n    });\n  }\n\n  if (isWriteOperation && !isRetryableWriteError(originalError)) {\n    throw originalError;\n  }\n\n  if (isReadOperation && !isRetryableReadError(originalError)) {\n    throw originalError;\n  }\n\n  if (\n    originalError instanceof MongoNetworkError &&\n    session.isPinned &&\n    !session.inTransaction() &&\n    operation.hasAspect(Aspect.CURSOR_CREATING)\n  ) {\n    // If we have a cursor and the initial command fails with a network error,\n    // we can retry it on another connection. So we need to check it back in, clear the\n    // pool for the service id, and retry again.\n    session.unpin({ force: true, forceClear: true });\n  }\n\n  // select a new server, and attempt to retry the operation\n  const server = await topology.selectServerAsync(selector, { session });\n\n  if (isWriteOperation && !supportsRetryableWrites(server)) {\n    throw new MongoUnexpectedServerResponseError(\n      'Selected server does not support retryable writes'\n    );\n  }\n\n  try {\n    return await operation.executeAsync(server, session);\n  } catch (retryError) {\n    if (\n      retryError instanceof MongoError &&\n      retryError.hasErrorLabel(MongoErrorLabel.NoWritesPerformed)\n    ) {\n      throw originalError;\n    }\n    throw retryError;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}