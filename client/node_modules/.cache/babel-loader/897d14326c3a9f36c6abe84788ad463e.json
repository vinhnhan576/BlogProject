{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.next = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst util_1 = require(\"util\");\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst get_more_1 = require(\"../operations/get_more\");\n\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\n\nconst promise_provider_1 = require(\"../promise_provider\");\n\nconst read_concern_1 = require(\"../read_concern\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n/** @internal */\n\n\nconst kId = Symbol('id');\n/** @internal */\n\nconst kDocuments = Symbol('documents');\n/** @internal */\n\nconst kServer = Symbol('server');\n/** @internal */\n\nconst kNamespace = Symbol('namespace');\n/** @internal */\n\nconst kClient = Symbol('client');\n/** @internal */\n\nconst kSession = Symbol('session');\n/** @internal */\n\nconst kOptions = Symbol('options');\n/** @internal */\n\nconst kTransform = Symbol('transform');\n/** @internal */\n\nconst kInitialized = Symbol('initialized');\n/** @internal */\n\nconst kClosed = Symbol('closed');\n/** @internal */\n\nconst kKilled = Symbol('killed');\n/** @internal */\n\nconst kInit = Symbol('kInit');\n/** @public */\n\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\n\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n\n    this[kClient] = client;\n    this[kNamespace] = namespace;\n    this[kId] = null;\n    this[kDocuments] = new utils_1.List();\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    };\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n\n    if (options.session instanceof sessions_1.ClientSession) {\n      this[kSession] = options.session;\n    } else {\n      this[kSession] = this[kClient].startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n  }\n\n  get id() {\n    var _a;\n\n    return (_a = this[kId]) !== null && _a !== void 0 ? _a : undefined;\n  }\n  /** @internal */\n\n\n  get client() {\n    return this[kClient];\n  }\n  /** @internal */\n\n\n  get server() {\n    return this[kServer];\n  }\n\n  get namespace() {\n    return this[kNamespace];\n  }\n\n  get readPreference() {\n    return this[kOptions].readPreference;\n  }\n\n  get readConcern() {\n    return this[kOptions].readConcern;\n  }\n  /** @internal */\n\n\n  get session() {\n    return this[kSession];\n  }\n\n  set session(clientSession) {\n    this[kSession] = clientSession;\n  }\n  /** @internal */\n\n\n  get cursorOptions() {\n    return this[kOptions];\n  }\n\n  get closed() {\n    return this[kClosed];\n  }\n\n  get killed() {\n    return this[kKilled];\n  }\n\n  get loadBalanced() {\n    var _a;\n\n    return !!((_a = this[kClient].topology) === null || _a === void 0 ? void 0 : _a.loadBalanced);\n  }\n  /** Returns current buffered documents length */\n\n\n  bufferedCount() {\n    return this[kDocuments].length;\n  }\n  /** Returns current buffered documents */\n\n\n  readBufferedDocuments(number) {\n    const bufferedDocs = [];\n    const documentsToRead = Math.min(number !== null && number !== void 0 ? number : this[kDocuments].length, this[kDocuments].length);\n\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this[kDocuments].shift();\n\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n\n    return bufferedDocs;\n  }\n\n  [Symbol.asyncIterator]() {\n    async function* nativeAsyncIterator() {\n      if (this.closed) {\n        return;\n      }\n\n      while (true) {\n        const document = await this.next(); // Intentional strict null check, because users can map cursors to falsey values.\n        // We allow mapping to all values except for null.\n        // eslint-disable-next-line no-restricted-syntax\n\n        if (document === null) {\n          if (!this.closed) {\n            const message = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n            await cleanupCursorAsync(this, {\n              needsToEmitClosed: true\n            }).catch(() => null);\n            throw new error_1.MongoAPIError(message);\n          }\n\n          break;\n        }\n\n        yield document;\n\n        if (this[kId] === bson_1.Long.ZERO) {\n          // Cursor exhausted\n          break;\n        }\n      }\n    }\n\n    const iterator = nativeAsyncIterator.call(this);\n\n    if (promise_provider_1.PromiseProvider.get() == null) {\n      return iterator;\n    }\n\n    return {\n      next: () => (0, utils_1.maybeCallback)(() => iterator.next(), null)\n    };\n  }\n\n  stream(options) {\n    if (options === null || options === void 0 ? void 0 : options.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n      return readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n\n      }));\n    }\n\n    return new ReadableCursorStream(this);\n  }\n\n  hasNext(callback) {\n    return (0, utils_1.maybeCallback)(async () => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return false;\n      }\n\n      if (this[kDocuments].length !== 0) {\n        return true;\n      }\n\n      const doc = await nextAsync(this, true);\n\n      if (doc) {\n        this[kDocuments].unshift(doc);\n        return true;\n      }\n\n      return false;\n    }, callback);\n  }\n\n  next(callback) {\n    return (0, utils_1.maybeCallback)(async () => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        throw new error_1.MongoCursorExhaustedError();\n      }\n\n      return nextAsync(this, true);\n    }, callback);\n  }\n\n  tryNext(callback) {\n    return (0, utils_1.maybeCallback)(async () => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        throw new error_1.MongoCursorExhaustedError();\n      }\n\n      return nextAsync(this, false);\n    }, callback);\n  }\n\n  forEach(iterator, callback) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n\n    return (0, utils_1.maybeCallback)(async () => {\n      for await (const document of this) {\n        const result = iterator(document);\n\n        if (result === false) {\n          break;\n        }\n      }\n    }, callback);\n  }\n\n  close(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n    return (0, utils_1.maybeCallback)(async () => cleanupCursorAsync(this, {\n      needsToEmitClosed\n    }), callback);\n  }\n\n  toArray(callback) {\n    return (0, utils_1.maybeCallback)(async () => {\n      const array = [];\n\n      for await (const document of this) {\n        array.push(document);\n      }\n\n      return array;\n    }, callback);\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n\n\n  addCursorFlag(flag, value) {\n    assertUninitialized(this);\n\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this[kOptions][flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n\n\n  map(transform) {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadPreference(readPreference) {\n    assertUninitialized(this);\n\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadConcern(readConcern) {\n    assertUninitialized(this);\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n\n\n  maxTimeMS(value) {\n    assertUninitialized(this);\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   */\n\n\n  batchSize(value) {\n    assertUninitialized(this);\n\n    if (this[kOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this[kOptions].batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n\n\n  rewind() {\n    if (!this[kInitialized]) {\n      return;\n    }\n\n    this[kId] = null;\n    this[kDocuments].clear();\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n    const session = this[kSession];\n\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().catch(() => null);\n        }\n\n        this[kSession] = this.client.startSession({\n          owner: this,\n          explicit: false\n        });\n      }\n    }\n  }\n  /** @internal */\n\n\n  _getMore(batchSize, callback) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], { ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    });\n    (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n\n\n  [kInit](callback) {\n    this._initialize(this[kSession], (error, state) => {\n      if (state) {\n        const response = state.response;\n        this[kServer] = state.server;\n\n        if (response.cursor) {\n          // TODO(NODE-2674): Preserve int64 sent from MongoDB\n          this[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n\n          if (response.cursor.ns) {\n            this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n          }\n\n          this[kDocuments].pushMany(response.cursor.firstBatch);\n        } // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n\n\n        if (this[kId] == null) {\n          this[kId] = bson_1.Long.ZERO; // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n\n          this[kDocuments].push(state.response);\n        }\n      } // the cursor is now initialized, even if an error occurred or it is dead\n\n\n      this[kInitialized] = true;\n\n      if (error) {\n        return cleanupCursor(this, {\n          error\n        }, () => callback(error, undefined));\n      }\n\n      if (cursorIsDead(this)) {\n        return cleanupCursor(this, undefined, () => callback());\n      }\n\n      callback();\n    });\n  }\n\n}\n\nexports.AbstractCursor = AbstractCursor;\n/** @event */\n\nAbstractCursor.CLOSE = 'close';\n\nfunction nextDocument(cursor) {\n  const doc = cursor[kDocuments].shift();\n\n  if (doc && cursor[kTransform]) {\n    return cursor[kTransform](doc);\n  }\n\n  return doc;\n}\n\nconst nextAsync = (0, util_1.promisify)(next);\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param callback - callback to return the result to the caller\n * @returns\n */\n\nfunction next(cursor, blocking, callback) {\n  const cursorId = cursor[kId];\n\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n\n  if (cursor[kDocuments].length !== 0) {\n    callback(undefined, nextDocument(cursor));\n    return;\n  }\n\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    cursor[kInit](err => {\n      if (err) return callback(err);\n      return next(cursor, blocking, callback);\n    });\n    return;\n  }\n\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n  } // otherwise need to call getMore\n\n\n  const batchSize = cursor[kOptions].batchSize || 1000;\n\n  cursor._getMore(batchSize, (error, response) => {\n    if (response) {\n      const cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n      cursor[kDocuments].pushMany(response.cursor.nextBatch);\n      cursor[kId] = cursorId;\n    }\n\n    if (error || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, {\n        error\n      }, () => callback(error, nextDocument(cursor)));\n    }\n\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n\n    next(cursor, blocking, callback);\n  });\n}\n\nexports.next = next;\n\nfunction cursorIsDead(cursor) {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\n\nconst cleanupCursorAsync = (0, util_1.promisify)(cleanupCursor);\n\nfunction cleanupCursor(cursor, options, callback) {\n  var _a;\n\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n  const needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;\n\n  if (error) {\n    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = bson_1.Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, callback);\n      }\n\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n\n    return callback();\n  }\n\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, () => {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n      }\n\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n\n  cursor[kKilled] = true;\n  return (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, {\n    session\n  }), completeCleanup);\n}\n/** @internal */\n\n\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoCursorInUseError();\n  }\n}\n\nexports.assertUninitialized = assertUninitialized;\n\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n\n      this._readNext();\n    }\n  }\n\n  _destroy(error, callback) {\n    this._cursor.close(err => process.nextTick(callback, err || error));\n  }\n\n  _readNext() {\n    next(this._cursor, true, (err, result) => {\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().catch(() => null);\n\n          return this.push(null);\n        } // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n\n\n        if (err.message.match(/operation was interrupted/)) {\n          return this.push(null);\n        } // NOTE: The two above checks on the message of the error will cause a null to be pushed\n        //       to the stream, thus closing the stream before the destroy call happens. This means\n        //       that either of those error messages on a change stream will not get a proper\n        //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n        //       relies on that error event to be emitted to create its new cursor and thus was not\n        //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n        //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n        //       See NODE-4475.\n\n\n        return this.destroy(err);\n      }\n\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().catch(() => null);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n\n        this._readInProgress = false;\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["kId","Symbol","kDocuments","kServer","kNamespace","kClient","kSession","kOptions","kTransform","kInitialized","kClosed","kKilled","kInit","exports","AbstractCursor","mongo_types_1","constructor","client","namespace","options","s","isMongoClient","error_1","utils_1","readPreference","read_preference_1","primary","readConcern","read_concern_1","fromOptions","batchSize","comment","undefined","maxTimeMS","maxAwaitTimeMS","session","sessions_1","startSession","owner","explicit","id","_a","server","clientSession","cursorOptions","closed","killed","loadBalanced","topology","bufferedCount","length","readBufferedDocuments","number","bufferedDocs","documentsToRead","Math","min","count","document","shift","push","asyncIterator","nativeAsyncIterator","next","message","cleanupCursorAsync","needsToEmitClosed","catch","bson_1","ZERO","iterator","call","promise_provider_1","get","stream","transform","readable","ReadableCursorStream","pipe","stream_1","objectMode","highWaterMark","chunk","_","callback","transformed","err","hasNext","doc","nextAsync","unshift","tryNext","forEach","result","close","toArray","array","addCursorFlag","flag","value","assertUninitialized","includes","map","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","tailable","rewind","clear","hasEnded","endSession","_getMore","getMoreOperation","get_more_1","_initialize","error","state","response","cursor","fromNumber","ns","pushMany","firstBatch","cleanupCursor","cursorIsDead","nextDocument","blocking","cursorId","nextBatch","isZero","cursorNs","completeCleanup","emit","CLOSE","inTransaction","kill_cursors_1","autoDestroy","_cursor","_read","size","_readInProgress","_readNext","_destroy","process","nextTick","match","destroy","destroyed"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\cursor\\abstract_cursor.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\nimport { promisify } from 'util';\n\nimport { BSONSerializeOptions, Document, Long, pluckBSONSerializeOptions } from '../bson';\nimport {\n  AnyError,\n  MongoAPIError,\n  MongoCursorExhaustedError,\n  MongoCursorInUseError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoRuntimeError,\n  MongoTailableCursorError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { TODO_NODE_3286, TypedEventEmitter } from '../mongo_types';\nimport { executeOperation, ExecutionResult } from '../operations/execute_operation';\nimport { GetMoreOperation } from '../operations/get_more';\nimport { KillCursorsOperation } from '../operations/kill_cursors';\nimport { PromiseProvider } from '../promise_provider';\nimport { ReadConcern, ReadConcernLike } from '../read_concern';\nimport { ReadPreference, ReadPreferenceLike } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport { ClientSession, maybeClearPinnedConnection } from '../sessions';\nimport { Callback, List, maybeCallback, MongoDBNamespace, ns } from '../utils';\n\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kClient = Symbol('client');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @internal */\nconst kInit = Symbol('kInit');\n\n/** @public */\nexport const CURSOR_FLAGS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'exhaust',\n  'partial'\n] as const;\n\n/** @public\n * @deprecated This interface is deprecated */\nexport interface CursorCloseOptions {\n  /** Bypass calling killCursors when closing the cursor. */\n  /** @deprecated  the skipKillCursors option is deprecated */\n  skipKillCursors?: boolean;\n}\n\n/** @public */\nexport interface CursorStreamOptions {\n  /** A transformation method applied to each document emitted by the stream */\n  transform?(this: void, doc: Document): Document;\n}\n\n/** @public */\nexport type CursorFlag = typeof CURSOR_FLAGS[number];\n\n/** @public */\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  /**\n   * Specifies the number of documents to return in each response from MongoDB\n   */\n  batchSize?: number;\n  /**\n   * When applicable `maxTimeMS` controls the amount of time the initial command\n   * that constructs a cursor should take. (ex. find, aggregate, listCollections)\n   */\n  maxTimeMS?: number;\n  /**\n   * When applicable `maxAwaitTimeMS` controls the amount of time subsequent getMores\n   * that a cursor uses to fetch more data should take. (ex. cursor.next())\n   */\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /**\n   * By default, MongoDB will automatically close a cursor when the\n   * client has exhausted all results in the cursor. However, for [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections)\n   * you may use a Tailable Cursor that remains open after the client exhausts\n   * the results in the initial cursor.\n   */\n  tailable?: boolean;\n  /**\n   * If awaitData is set to true, when the cursor reaches the end of the capped collection,\n   * MongoDB blocks the query thread for a period of time waiting for new data to arrive.\n   * When new data is inserted into the capped collection, the blocked thread is signaled\n   * to wake up and return the next batch to the client.\n   */\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n}\n\n/** @internal */\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\n  // resolved\n  readPreference: ReadPreference;\n  readConcern?: ReadConcern;\n\n  // cursor flags, some are deprecated\n  oplogReplay?: boolean;\n  exhaust?: boolean;\n  partial?: boolean;\n};\n\n/** @public */\nexport type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\nexport abstract class AbstractCursor<\n  TSchema = any,\n  CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\n> extends TypedEventEmitter<CursorEvents> {\n  /** @internal */\n  [kId]: Long | null;\n  /** @internal */\n  [kSession]: ClientSession;\n  /** @internal */\n  [kServer]?: Server;\n  /** @internal */\n  [kNamespace]: MongoDBNamespace;\n  /** @internal */\n  [kDocuments]: List<TSchema>;\n  /** @internal */\n  [kClient]: MongoClient;\n  /** @internal */\n  [kTransform]?: (doc: TSchema) => any;\n  /** @internal */\n  [kInitialized]: boolean;\n  /** @internal */\n  [kClosed]: boolean;\n  /** @internal */\n  [kKilled]: boolean;\n  /** @internal */\n  [kOptions]: InternalAbstractCursorOptions;\n\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n\n  /** @internal */\n  constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    options: AbstractCursorOptions = {}\n  ) {\n    super();\n\n    if (!client.s.isMongoClient) {\n      throw new MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this[kClient] = client;\n    this[kNamespace] = namespace;\n    this[kId] = null;\n    this[kDocuments] = new List();\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference:\n        options.readPreference && options.readPreference instanceof ReadPreference\n          ? options.readPreference\n          : ReadPreference.primary,\n      ...pluckBSONSerializeOptions(options)\n    };\n\n    const readConcern = ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n\n    if (options.session instanceof ClientSession) {\n      this[kSession] = options.session;\n    } else {\n      this[kSession] = this[kClient].startSession({ owner: this, explicit: false });\n    }\n  }\n\n  get id(): Long | undefined {\n    return this[kId] ?? undefined;\n  }\n\n  /** @internal */\n  get client(): MongoClient {\n    return this[kClient];\n  }\n\n  /** @internal */\n  get server(): Server | undefined {\n    return this[kServer];\n  }\n\n  get namespace(): MongoDBNamespace {\n    return this[kNamespace];\n  }\n\n  get readPreference(): ReadPreference {\n    return this[kOptions].readPreference;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this[kOptions].readConcern;\n  }\n\n  /** @internal */\n  get session(): ClientSession {\n    return this[kSession];\n  }\n\n  set session(clientSession: ClientSession) {\n    this[kSession] = clientSession;\n  }\n\n  /** @internal */\n  get cursorOptions(): InternalAbstractCursorOptions {\n    return this[kOptions];\n  }\n\n  get closed(): boolean {\n    return this[kClosed];\n  }\n\n  get killed(): boolean {\n    return this[kKilled];\n  }\n\n  get loadBalanced(): boolean {\n    return !!this[kClient].topology?.loadBalanced;\n  }\n\n  /** Returns current buffered documents length */\n  bufferedCount(): number {\n    return this[kDocuments].length;\n  }\n\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): TSchema[] {\n    const bufferedDocs: TSchema[] = [];\n    const documentsToRead = Math.min(number ?? this[kDocuments].length, this[kDocuments].length);\n\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this[kDocuments].shift();\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n\n    return bufferedDocs;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<TSchema, void> {\n    async function* nativeAsyncIterator(this: AbstractCursor<TSchema>) {\n      if (this.closed) {\n        return;\n      }\n\n      while (true) {\n        const document = await this.next();\n\n        // Intentional strict null check, because users can map cursors to falsey values.\n        // We allow mapping to all values except for null.\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          if (!this.closed) {\n            const message =\n              'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n\n            await cleanupCursorAsync(this, { needsToEmitClosed: true }).catch(() => null);\n\n            throw new MongoAPIError(message);\n          }\n          break;\n        }\n\n        yield document;\n\n        if (this[kId] === Long.ZERO) {\n          // Cursor exhausted\n          break;\n        }\n      }\n    }\n\n    const iterator = nativeAsyncIterator.call(this);\n\n    if (PromiseProvider.get() == null) {\n      return iterator;\n    }\n    return {\n      next: () => maybeCallback(() => iterator.next(), null)\n    };\n  }\n\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema> {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n\n      return readable.pipe(\n        new Transform({\n          objectMode: true,\n          highWaterMark: 1,\n          transform(chunk, _, callback) {\n            try {\n              const transformed = transform(chunk);\n              callback(undefined, transformed);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        })\n      );\n    }\n\n    return new ReadableCursorStream(this);\n  }\n\n  hasNext(): Promise<boolean>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  hasNext(callback: Callback<boolean>): void;\n  hasNext(callback?: Callback<boolean>): Promise<boolean> | void {\n    return maybeCallback(async () => {\n      if (this[kId] === Long.ZERO) {\n        return false;\n      }\n\n      if (this[kDocuments].length !== 0) {\n        return true;\n      }\n\n      const doc = await nextAsync<TSchema>(this, true);\n\n      if (doc) {\n        this[kDocuments].unshift(doc);\n        return true;\n      }\n\n      return false;\n    }, callback);\n  }\n\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  next(): Promise<TSchema | null>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  next(callback: Callback<TSchema | null>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  next(callback?: Callback<TSchema | null>): Promise<TSchema | null> | void;\n  next(callback?: Callback<TSchema | null>): Promise<TSchema | null> | void {\n    return maybeCallback(async () => {\n      if (this[kId] === Long.ZERO) {\n        throw new MongoCursorExhaustedError();\n      }\n\n      return nextAsync(this, true);\n    }, callback);\n  }\n\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  tryNext(): Promise<TSchema | null>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  tryNext(callback: Callback<TSchema | null>): void;\n  tryNext(callback?: Callback<TSchema | null>): Promise<TSchema | null> | void {\n    return maybeCallback(async () => {\n      if (this[kId] === Long.ZERO) {\n        throw new MongoCursorExhaustedError();\n      }\n\n      return nextAsync(this, false);\n    }, callback);\n  }\n\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @param callback - The end callback.\n   */\n  forEach(iterator: (doc: TSchema) => boolean | void): Promise<void>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  forEach(iterator: (doc: TSchema) => boolean | void, callback: Callback<void>): void;\n  forEach(\n    iterator: (doc: TSchema) => boolean | void,\n    callback?: Callback<void>\n  ): Promise<void> | void {\n    if (typeof iterator !== 'function') {\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    return maybeCallback(async () => {\n      for await (const document of this) {\n        const result = iterator(document);\n        if (result === false) {\n          break;\n        }\n      }\n    }, callback);\n  }\n\n  close(): Promise<void>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  close(callback: Callback): void;\n  /**\n   * @deprecated options argument is deprecated\n   */\n  close(options: CursorCloseOptions): Promise<void>;\n  /**\n   * @deprecated options argument is deprecated. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance\n   */\n  close(options: CursorCloseOptions, callback: Callback): void;\n  close(options?: CursorCloseOptions | Callback, callback?: Callback): Promise<void> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n\n    return maybeCallback(async () => cleanupCursorAsync(this, { needsToEmitClosed }), callback);\n  }\n\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   *\n   * @param callback - The result callback.\n   */\n  toArray(): Promise<TSchema[]>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  toArray(callback: Callback<TSchema[]>): void;\n  toArray(callback?: Callback<TSchema[]>): Promise<TSchema[]> | void {\n    return maybeCallback(async () => {\n      const array = [];\n      for await (const document of this) {\n        array.push(document);\n      }\n      return array;\n    }, callback);\n  }\n\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\n    assertUninitialized(this);\n    if (!CURSOR_FLAGS.includes(flag)) {\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this[kOptions][flag] = value;\n    return this;\n  }\n\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform] as (doc: TSchema) => TSchema; // TODO(NODE-3283): Improve transform typing\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n\n    return this as unknown as AbstractCursor<T>;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this {\n    assertUninitialized(this);\n    if (readPreference instanceof ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = ReadPreference.fromString(readPreference);\n    } else {\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this {\n    assertUninitialized(this);\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this {\n    assertUninitialized(this);\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this {\n    assertUninitialized(this);\n    if (this[kOptions].tailable) {\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this[kOptions].batchSize = value;\n    return this;\n  }\n\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void {\n    if (!this[kInitialized]) {\n      return;\n    }\n\n    this[kId] = null;\n    this[kDocuments].clear();\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n\n    const session = this[kSession];\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().catch(() => null);\n        }\n        this[kSession] = this.client.startSession({ owner: this, explicit: false });\n      }\n    }\n  }\n\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n\n  /** @internal */\n  abstract _initialize(\n    session: ClientSession | undefined,\n    callback: Callback<ExecutionResult>\n  ): void;\n\n  /** @internal */\n  _getMore(batchSize: number, callback: Callback<Document>): void {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const getMoreOperation = new GetMoreOperation(this[kNamespace], this[kId]!, this[kServer]!, {\n      ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    });\n\n    executeOperation(this[kClient], getMoreOperation, callback);\n  }\n\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  [kInit](callback: Callback<TSchema | null>): void {\n    this._initialize(this[kSession], (error, state) => {\n      if (state) {\n        const response = state.response;\n        this[kServer] = state.server;\n\n        if (response.cursor) {\n          // TODO(NODE-2674): Preserve int64 sent from MongoDB\n          this[kId] =\n            typeof response.cursor.id === 'number'\n              ? Long.fromNumber(response.cursor.id)\n              : response.cursor.id;\n\n          if (response.cursor.ns) {\n            this[kNamespace] = ns(response.cursor.ns);\n          }\n\n          this[kDocuments].pushMany(response.cursor.firstBatch);\n        }\n\n        // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n        if (this[kId] == null) {\n          this[kId] = Long.ZERO;\n          // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n          this[kDocuments].push(state.response as TODO_NODE_3286);\n        }\n      }\n\n      // the cursor is now initialized, even if an error occurred or it is dead\n      this[kInitialized] = true;\n\n      if (error) {\n        return cleanupCursor(this, { error }, () => callback(error, undefined));\n      }\n\n      if (cursorIsDead(this)) {\n        return cleanupCursor(this, undefined, () => callback());\n      }\n\n      callback();\n    });\n  }\n}\n\nfunction nextDocument<T>(cursor: AbstractCursor<T>): T | null {\n  const doc = cursor[kDocuments].shift();\n\n  if (doc && cursor[kTransform]) {\n    return cursor[kTransform](doc) as T;\n  }\n\n  return doc;\n}\n\nconst nextAsync = promisify(\n  next as <T>(\n    cursor: AbstractCursor<T>,\n    blocking: boolean,\n    callback: (e: Error, r: T | null) => void\n  ) => void\n);\n\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param callback - callback to return the result to the caller\n * @returns\n */\nexport function next<T>(\n  cursor: AbstractCursor<T>,\n  blocking: boolean,\n  callback: Callback<T | null>\n): void {\n  const cursorId = cursor[kId];\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n\n  if (cursor[kDocuments].length !== 0) {\n    callback(undefined, nextDocument<T>(cursor));\n    return;\n  }\n\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    cursor[kInit](err => {\n      if (err) return callback(err);\n      return next(cursor, blocking, callback);\n    });\n\n    return;\n  }\n\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n  }\n\n  // otherwise need to call getMore\n  const batchSize = cursor[kOptions].batchSize || 1000;\n  cursor._getMore(batchSize, (error, response) => {\n    if (response) {\n      const cursorId =\n        typeof response.cursor.id === 'number'\n          ? Long.fromNumber(response.cursor.id)\n          : response.cursor.id;\n\n      cursor[kDocuments].pushMany(response.cursor.nextBatch);\n      cursor[kId] = cursorId;\n    }\n\n    if (error || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, { error }, () => callback(error, nextDocument<T>(cursor)));\n    }\n\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n\n    next(cursor, blocking, callback);\n  });\n}\n\nfunction cursorIsDead(cursor: AbstractCursor): boolean {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\n\nconst cleanupCursorAsync = promisify(cleanupCursor);\n\nfunction cleanupCursor(\n  cursor: AbstractCursor,\n  options: { error?: AnyError | undefined; needsToEmitClosed?: boolean } | undefined,\n  callback: Callback\n): void {\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options?.error;\n  const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;\n\n  if (error) {\n    if (cursor.loadBalanced && error instanceof MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({ error }, callback);\n      }\n\n      if (!session.inTransaction()) {\n        maybeClearPinnedConnection(session, { error });\n      }\n    }\n\n    return callback();\n  }\n\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({ error }, () => {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n      }\n\n      if (!session.inTransaction()) {\n        maybeClearPinnedConnection(session, { error });\n      }\n    }\n\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n\n  cursor[kKilled] = true;\n\n  return executeOperation(\n    cursor[kClient],\n    new KillCursorsOperation(cursorId, cursorNs, server, { session }),\n    completeCleanup\n  );\n}\n\n/** @internal */\nexport function assertUninitialized(cursor: AbstractCursor): void {\n  if (cursor[kInitialized]) {\n    throw new MongoCursorInUseError();\n  }\n}\n\nclass ReadableCursorStream extends Readable {\n  private _cursor: AbstractCursor;\n  private _readInProgress = false;\n\n  constructor(cursor: AbstractCursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._cursor = cursor;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override _read(size: number): void {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n\n  override _destroy(error: Error | null, callback: (error?: Error | null) => void): void {\n    this._cursor.close(err => process.nextTick(callback, err || error));\n  }\n\n  private _readNext() {\n    next(this._cursor, true, (err, result) => {\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().catch(() => null);\n          return this.push(null);\n        }\n\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n        if (err.message.match(/operation was interrupted/)) {\n          return this.push(null);\n        }\n\n        // NOTE: The two above checks on the message of the error will cause a null to be pushed\n        //       to the stream, thus closing the stream before the destroy call happens. This means\n        //       that either of those error messages on a change stream will not get a proper\n        //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n        //       relies on that error event to be emitted to create its new cursor and thus was not\n        //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n        //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n        //       See NODE-4475.\n        return this.destroy(err);\n      }\n\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().catch(() => null);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n\n        this._readInProgress = false;\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}