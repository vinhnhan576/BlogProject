{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TopologyDescription = void 0;\n\nconst WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst common_1 = require(\"./common\");\n\nconst server_description_1 = require(\"./server_description\"); // constants related to compatibility checks\n\n\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set([common_1.ServerType.RSSecondary, common_1.ServerType.RSArbiter, common_1.ServerType.RSOther]);\n/**\n * Representation of a deployment of servers\n * @public\n */\n\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(topologyType) {\n    let serverDescriptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let maxSetVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let maxElectionId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let commonWireVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n\n    var _a, _b;\n\n    options = options !== null && options !== void 0 ? options : {};\n    this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n    this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;\n    this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 15;\n    this.setName = setName !== null && setName !== void 0 ? setName : null;\n    this.maxElectionId = maxElectionId !== null && maxElectionId !== void 0 ? maxElectionId : null;\n    this.maxSetVersion = maxSetVersion !== null && maxSetVersion !== void 0 ? maxSetVersion : null;\n    this.commonWireVersion = commonWireVersion !== null && commonWireVersion !== void 0 ? commonWireVersion : 0; // determine server compatibility\n\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    } // Whenever a client updates the TopologyDescription from a hello response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n\n\n    this.logicalSessionTimeoutMinutes = null;\n\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = null;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        } // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n\n\n        this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n      }\n    }\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n\n\n  updateFromSrvPollingEvent(ev) {\n    let srvMaxHosts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    /** The SRV addresses defines the set of addresses we should be using */\n    const incomingHostnames = ev.hostnames();\n    const currentHostnames = new Set(this.servers.keys());\n    const hostnamesToAdd = new Set(incomingHostnames);\n    const hostnamesToRemove = new Set();\n\n    for (const hostname of currentHostnames) {\n      // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\n      hostnamesToAdd.delete(hostname);\n\n      if (!incomingHostnames.has(hostname)) {\n        // If the SRV Records no longer include this hostname\n        // we have to stop using it\n        hostnamesToRemove.add(hostname);\n      }\n    }\n\n    if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\n      // No new hosts to add and none to remove\n      return this;\n    }\n\n    const serverDescriptions = new Map(this.servers);\n\n    for (const removedHost of hostnamesToRemove) {\n      serverDescriptions.delete(removedHost);\n    }\n\n    if (hostnamesToAdd.size > 0) {\n      if (srvMaxHosts === 0) {\n        // Add all!\n        for (const hostToAdd of hostnamesToAdd) {\n          serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));\n        }\n      } else if (serverDescriptions.size < srvMaxHosts) {\n        // Add only the amount needed to get us back to srvMaxHosts\n        const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\n\n        for (const selectedHostToAdd of selectedHosts) {\n          serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));\n        }\n      }\n    }\n\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n\n\n  update(serverDescription) {\n    const address = serverDescription.address; // potentially mutated values\n\n    let {\n      type: topologyType,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion\n    } = this;\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers); // update common wire version\n\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    if (typeof serverDescription.setName === 'string' && typeof setName === 'string' && serverDescription.setName !== setName) {\n      if (topologyType === common_1.TopologyType.Single) {\n        // \"Single\" Topology with setName mismatch is direct connection usage, mark unknown do not remove\n        serverDescription = new server_description_1.ServerDescription(address);\n      } else {\n        serverDescriptions.delete(address);\n      }\n    } // update the actual server description\n\n\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === common_1.TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n        heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n        localThresholdMS: this.localThresholdMS\n      });\n    }\n\n    if (topologyType === common_1.TopologyType.Unknown) {\n      if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n\n    return null;\n  }\n  /**\n   * Determines if the topology description has any known servers\n   */\n\n\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== common_1.ServerType.Unknown);\n  }\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n\n\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n\n\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n\n}\n\nexports.TopologyDescription = TopologyDescription;\n\nfunction topologyTypeForServerType(serverType) {\n  switch (serverType) {\n    case common_1.ServerType.Standalone:\n      return common_1.TopologyType.Single;\n\n    case common_1.ServerType.Mongos:\n      return common_1.TopologyType.Sharded;\n\n    case common_1.ServerType.RSPrimary:\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n\n    case common_1.ServerType.RSOther:\n    case common_1.ServerType.RSSecondary:\n      return common_1.TopologyType.ReplicaSetNoPrimary;\n\n    default:\n      return common_1.TopologyType.Unknown;\n  }\n}\n\nfunction updateRsFromPrimary(serverDescriptions, serverDescription) {\n  let setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let maxSetVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let maxElectionId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  var _a;\n\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  if (serverDescription.maxWireVersion >= 17) {\n    const electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);\n    const maxElectionIdIsEqual = electionIdComparison === 0;\n    const maxElectionIdIsLess = electionIdComparison === -1;\n    const maxSetVersionIsLessOrEqual = (maxSetVersion !== null && maxSetVersion !== void 0 ? maxSetVersion : -1) <= ((_a = serverDescription.setVersion) !== null && _a !== void 0 ? _a : -1);\n\n    if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {\n      // The reported electionId was greater\n      // or the electionId was equal and reported setVersion was greater\n      // Always update both values, they are a tuple\n      maxElectionId = serverDescription.electionId;\n      maxSetVersion = serverDescription.setVersion;\n    } else {\n      // Stale primary\n      // replace serverDescription with a default ServerDescription of type \"Unknown\"\n      serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n    }\n  } else {\n    const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n\n    if (serverDescription.setVersion && electionId) {\n      if (maxSetVersion && maxElectionId) {\n        if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {\n          // this primary is stale, we must remove it\n          serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n        }\n      }\n\n      maxElectionId = serverDescription.electionId;\n    }\n\n    if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n      maxSetVersion = serverDescription.setVersion;\n    }\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new server_description_1.ServerDescription(server.address)); // There can only be one primary\n\n      break;\n    }\n  } // Discover new hosts from this primary's response.\n\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription) {\n  let setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription) {\n  let setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n  setName = setName !== null && setName !== void 0 ? setName : serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === common_1.ServerType.RSPrimary) {\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return common_1.TopologyType.ReplicaSetNoPrimary;\n}","map":{"version":3,"mappings":"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","names":["MIN_SUPPORTED_SERVER_VERSION","WIRE_CONSTANTS","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","MONGOS_OR_UNKNOWN","Set","common_1","Mongos","Unknown","MONGOS_OR_STANDALONE","Standalone","NON_PRIMARY_RS_MEMBERS","RSSecondary","RSArbiter","RSOther","TopologyDescription","constructor","topologyType","serverDescriptions","setName","maxSetVersion","maxElectionId","commonWireVersion","options","type","servers","Map","stale","compatible","heartbeatFrequencyMS","_a","localThresholdMS","_b","serverDescription","values","LoadBalancer","minWireVersion","compatibilityError","address","maxWireVersion","logicalSessionTimeoutMinutes","server","isReadable","Math","min","updateFromSrvPollingEvent","ev","srvMaxHosts","incomingHostnames","hostnames","currentHostnames","keys","hostnamesToAdd","hostnamesToRemove","hostname","delete","has","add","size","removedHost","hostToAdd","set","server_description_1","selectedHosts","selectedHostToAdd","update","serverType","Single","topologyTypeForServerType","Sharded","ReplicaSetNoPrimary","RSPrimary","result","updateRsFromPrimary","updateRsNoPrimaryFromMember","ReplicaSetWithPrimary","checkHasPrimary","updateRsWithPrimaryFromMember","error","descriptionsWithError","Array","from","filter","sd","length","hasKnownServers","some","hasDataBearingServers","isDataBearing","hasServer","exports","electionIdComparison","electionId","maxElectionIdIsEqual","maxElectionIdIsLess","maxSetVersionIsLessOrEqual","setVersion","allHosts","forEach","currentAddresses","responseAddresses","addr","indexOf","error_1","me"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\sdam\\topology_description.ts"],"sourcesContent":["import type { ObjectId } from '../bson';\nimport * as WIRE_CONSTANTS from '../cmap/wire_protocol/constants';\nimport { MongoRuntimeError, MongoServerError } from '../error';\nimport { compareObjectId, shuffle } from '../utils';\nimport { ServerType, TopologyType } from './common';\nimport { ServerDescription } from './server_description';\nimport type { SrvPollingEvent } from './srv_polling';\n\n// constants related to compatibility checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\nconst MONGOS_OR_UNKNOWN = new Set<ServerType>([ServerType.Mongos, ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set<ServerType>([ServerType.Mongos, ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set<ServerType>([\n  ServerType.RSSecondary,\n  ServerType.RSArbiter,\n  ServerType.RSOther\n]);\n\n/** @public */\nexport interface TopologyDescriptionOptions {\n  heartbeatFrequencyMS?: number;\n  localThresholdMS?: number;\n}\n\n/**\n * Representation of a deployment of servers\n * @public\n */\nexport class TopologyDescription {\n  type: TopologyType;\n  setName: string | null;\n  maxSetVersion: number | null;\n  maxElectionId: ObjectId | null;\n  servers: Map<string, ServerDescription>;\n  stale: boolean;\n  compatible: boolean;\n  compatibilityError?: string;\n  logicalSessionTimeoutMinutes: number | null;\n  heartbeatFrequencyMS: number;\n  localThresholdMS: number;\n  commonWireVersion: number;\n\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(\n    topologyType: TopologyType,\n    serverDescriptions: Map<string, ServerDescription> | null = null,\n    setName: string | null = null,\n    maxSetVersion: number | null = null,\n    maxElectionId: ObjectId | null = null,\n    commonWireVersion: number | null = null,\n    options: TopologyDescriptionOptions | null = null\n  ) {\n    options = options ?? {};\n\n    this.type = topologyType ?? TopologyType.Unknown;\n    this.servers = serverDescriptions ?? new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;\n    this.localThresholdMS = options.localThresholdMS ?? 15;\n    this.setName = setName ?? null;\n    this.maxElectionId = maxElectionId ?? null;\n    this.maxSetVersion = maxSetVersion ?? null;\n    this.commonWireVersion = commonWireVersion ?? 0;\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (\n        serverDescription.type === ServerType.Unknown ||\n        serverDescription.type === ServerType.LoadBalancer\n      ) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from a hello response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    this.logicalSessionTimeoutMinutes = null;\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = null;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        }\n\n        // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n        this.logicalSessionTimeoutMinutes = Math.min(\n          this.logicalSessionTimeoutMinutes,\n          server.logicalSessionTimeoutMinutes\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n  updateFromSrvPollingEvent(ev: SrvPollingEvent, srvMaxHosts = 0): TopologyDescription {\n    /** The SRV addresses defines the set of addresses we should be using */\n    const incomingHostnames = ev.hostnames();\n    const currentHostnames = new Set(this.servers.keys());\n\n    const hostnamesToAdd = new Set<string>(incomingHostnames);\n    const hostnamesToRemove = new Set<string>();\n    for (const hostname of currentHostnames) {\n      // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\n      hostnamesToAdd.delete(hostname);\n      if (!incomingHostnames.has(hostname)) {\n        // If the SRV Records no longer include this hostname\n        // we have to stop using it\n        hostnamesToRemove.add(hostname);\n      }\n    }\n\n    if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\n      // No new hosts to add and none to remove\n      return this;\n    }\n\n    const serverDescriptions = new Map(this.servers);\n    for (const removedHost of hostnamesToRemove) {\n      serverDescriptions.delete(removedHost);\n    }\n\n    if (hostnamesToAdd.size > 0) {\n      if (srvMaxHosts === 0) {\n        // Add all!\n        for (const hostToAdd of hostnamesToAdd) {\n          serverDescriptions.set(hostToAdd, new ServerDescription(hostToAdd));\n        }\n      } else if (serverDescriptions.size < srvMaxHosts) {\n        // Add only the amount needed to get us back to srvMaxHosts\n        const selectedHosts = shuffle(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\n        for (const selectedHostToAdd of selectedHosts) {\n          serverDescriptions.set(selectedHostToAdd, new ServerDescription(selectedHostToAdd));\n        }\n      }\n    }\n\n    return new TopologyDescription(\n      this.type,\n      serverDescriptions,\n      this.setName,\n      this.maxSetVersion,\n      this.maxElectionId,\n      this.commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n  update(serverDescription: ServerDescription): TopologyDescription {\n    const address = serverDescription.address;\n\n    // potentially mutated values\n    let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;\n\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    if (\n      typeof serverDescription.setName === 'string' &&\n      typeof setName === 'string' &&\n      serverDescription.setName !== setName\n    ) {\n      if (topologyType === TopologyType.Single) {\n        // \"Single\" Topology with setName mismatch is direct connection usage, mark unknown do not remove\n        serverDescription = new ServerDescription(address);\n      } else {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(\n        TopologyType.Single,\n        serverDescriptions,\n        setName,\n        maxSetVersion,\n        maxElectionId,\n        commonWireVersion,\n        { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n      );\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(\n          serverDescriptions,\n          serverDescription,\n          setName\n        );\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(\n      topologyType,\n      serverDescriptions,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  get error(): MongoServerError | null {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(\n      (sd: ServerDescription) => sd.error\n    );\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n\n    return null;\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers(): boolean {\n    return Array.from(this.servers.values()).some(\n      (sd: ServerDescription) => sd.type !== ServerType.Unknown\n    );\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers(): boolean {\n    return Array.from(this.servers.values()).some((sd: ServerDescription) => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n  hasServer(address: string): boolean {\n    return this.servers.has(address);\n  }\n}\n\nfunction topologyTypeForServerType(serverType: ServerType): TopologyType {\n  switch (serverType) {\n    case ServerType.Standalone:\n      return TopologyType.Single;\n    case ServerType.Mongos:\n      return TopologyType.Sharded;\n    case ServerType.RSPrimary:\n      return TopologyType.ReplicaSetWithPrimary;\n    case ServerType.RSOther:\n    case ServerType.RSSecondary:\n      return TopologyType.ReplicaSetNoPrimary;\n    default:\n      return TopologyType.Unknown;\n  }\n}\n\nfunction updateRsFromPrimary(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null,\n  maxSetVersion: number | null = null,\n  maxElectionId: ObjectId | null = null\n): [TopologyType, string | null, number | null, ObjectId | null] {\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  if (serverDescription.maxWireVersion >= 17) {\n    const electionIdComparison = compareObjectId(maxElectionId, serverDescription.electionId);\n    const maxElectionIdIsEqual = electionIdComparison === 0;\n    const maxElectionIdIsLess = electionIdComparison === -1;\n    const maxSetVersionIsLessOrEqual =\n      (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);\n\n    if (maxElectionIdIsLess || (maxElectionIdIsEqual && maxSetVersionIsLessOrEqual)) {\n      // The reported electionId was greater\n      // or the electionId was equal and reported setVersion was greater\n      // Always update both values, they are a tuple\n      maxElectionId = serverDescription.electionId;\n      maxSetVersion = serverDescription.setVersion;\n    } else {\n      // Stale primary\n      // replace serverDescription with a default ServerDescription of type \"Unknown\"\n      serverDescriptions.set(\n        serverDescription.address,\n        new ServerDescription(serverDescription.address)\n      );\n\n      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n    }\n  } else {\n    const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n    if (serverDescription.setVersion && electionId) {\n      if (maxSetVersion && maxElectionId) {\n        if (\n          maxSetVersion > serverDescription.setVersion ||\n          compareObjectId(maxElectionId, electionId) > 0\n        ) {\n          // this primary is stale, we must remove it\n          serverDescriptions.set(\n            serverDescription.address,\n            new ServerDescription(serverDescription.address)\n          );\n\n          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n        }\n      }\n\n      maxElectionId = serverDescription.electionId;\n    }\n\n    if (\n      serverDescription.setVersion != null &&\n      (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\n    ) {\n      maxSetVersion = serverDescription.setVersion;\n    }\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address));\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses\n    .filter((addr: string) => responseAddresses.indexOf(addr) === -1)\n    .forEach((address: string) => {\n      serverDescriptions.delete(address);\n    });\n\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null\n): TopologyType {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (\n    setName !== serverDescription.setName ||\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\n  ) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null\n): [TopologyType, string | null] {\n  const topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName ?? serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions: Map<string, ServerDescription>): TopologyType {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n"]},"metadata":{},"sourceType":"script"}