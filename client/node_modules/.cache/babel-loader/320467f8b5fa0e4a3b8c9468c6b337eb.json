{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compareTopologyVersion = exports.parseServerType = exports.ServerDescription = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst common_1 = require(\"./common\");\n\nconst WRITABLE_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.Standalone, common_1.ServerType.Mongos, common_1.ServerType.LoadBalancer]);\nconst DATA_BEARING_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.RSSecondary, common_1.ServerType.Mongos, common_1.ServerType.Standalone, common_1.ServerType.LoadBalancer]);\n/**\n * The client's view of a single server, based on the most recent hello outcome.\n *\n * Internal type, not meant to be directly instantiated\n * @public\n */\n\nclass ServerDescription {\n  /**\n   * Create a ServerDescription\n   * @internal\n   *\n   * @param address - The address of the server\n   * @param hello - An optional hello response for this server\n   */\n  constructor(address, hello) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;\n\n    if (address == null || address === '') {\n      throw new error_1.MongoRuntimeError('ServerDescription must be provided with a non-empty address');\n    }\n\n    this.address = typeof address === 'string' ? utils_1.HostAddress.fromString(address).toString() // Use HostAddress to normalize\n    : address.toString();\n    this.type = parseServerType(hello, options);\n    this.hosts = (_b = (_a = hello === null || hello === void 0 ? void 0 : hello.hosts) === null || _a === void 0 ? void 0 : _a.map(host => host.toLowerCase())) !== null && _b !== void 0 ? _b : [];\n    this.passives = (_d = (_c = hello === null || hello === void 0 ? void 0 : hello.passives) === null || _c === void 0 ? void 0 : _c.map(host => host.toLowerCase())) !== null && _d !== void 0 ? _d : [];\n    this.arbiters = (_f = (_e = hello === null || hello === void 0 ? void 0 : hello.arbiters) === null || _e === void 0 ? void 0 : _e.map(host => host.toLowerCase())) !== null && _f !== void 0 ? _f : [];\n    this.tags = (_g = hello === null || hello === void 0 ? void 0 : hello.tags) !== null && _g !== void 0 ? _g : {};\n    this.minWireVersion = (_h = hello === null || hello === void 0 ? void 0 : hello.minWireVersion) !== null && _h !== void 0 ? _h : 0;\n    this.maxWireVersion = (_j = hello === null || hello === void 0 ? void 0 : hello.maxWireVersion) !== null && _j !== void 0 ? _j : 0;\n    this.roundTripTime = (_k = options === null || options === void 0 ? void 0 : options.roundTripTime) !== null && _k !== void 0 ? _k : -1;\n    this.lastUpdateTime = (0, utils_1.now)();\n    this.lastWriteDate = (_m = (_l = hello === null || hello === void 0 ? void 0 : hello.lastWrite) === null || _l === void 0 ? void 0 : _l.lastWriteDate) !== null && _m !== void 0 ? _m : 0;\n    this.error = (_o = options.error) !== null && _o !== void 0 ? _o : null; // TODO(NODE-2674): Preserve int64 sent from MongoDB\n\n    this.topologyVersion = (_r = (_q = (_p = this.error) === null || _p === void 0 ? void 0 : _p.topologyVersion) !== null && _q !== void 0 ? _q : hello === null || hello === void 0 ? void 0 : hello.topologyVersion) !== null && _r !== void 0 ? _r : null;\n    this.setName = (_s = hello === null || hello === void 0 ? void 0 : hello.setName) !== null && _s !== void 0 ? _s : null;\n    this.setVersion = (_t = hello === null || hello === void 0 ? void 0 : hello.setVersion) !== null && _t !== void 0 ? _t : null;\n    this.electionId = (_u = hello === null || hello === void 0 ? void 0 : hello.electionId) !== null && _u !== void 0 ? _u : null;\n    this.logicalSessionTimeoutMinutes = (_v = hello === null || hello === void 0 ? void 0 : hello.logicalSessionTimeoutMinutes) !== null && _v !== void 0 ? _v : null;\n    this.primary = (_w = hello === null || hello === void 0 ? void 0 : hello.primary) !== null && _w !== void 0 ? _w : null;\n    this.me = (_y = (_x = hello === null || hello === void 0 ? void 0 : hello.me) === null || _x === void 0 ? void 0 : _x.toLowerCase()) !== null && _y !== void 0 ? _y : null;\n    this.$clusterTime = (_z = hello === null || hello === void 0 ? void 0 : hello.$clusterTime) !== null && _z !== void 0 ? _z : null;\n  }\n\n  get hostAddress() {\n    return utils_1.HostAddress.fromString(this.address);\n  }\n\n  get allHosts() {\n    return this.hosts.concat(this.arbiters).concat(this.passives);\n  }\n  /** Is this server available for reads*/\n\n\n  get isReadable() {\n    return this.type === common_1.ServerType.RSSecondary || this.isWritable;\n  }\n  /** Is this server data bearing */\n\n\n  get isDataBearing() {\n    return DATA_BEARING_SERVER_TYPES.has(this.type);\n  }\n  /** Is this server available for writes */\n\n\n  get isWritable() {\n    return WRITABLE_SERVER_TYPES.has(this.type);\n  }\n\n  get host() {\n    const chopLength = `:${this.port}`.length;\n    return this.address.slice(0, -chopLength);\n  }\n\n  get port() {\n    const port = this.address.split(':').pop();\n    return port ? Number.parseInt(port, 10) : 27017;\n  }\n  /**\n   * Determines if another `ServerDescription` is equal to this one per the rules defined\n   * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}\n   */\n\n\n  equals(other) {\n    // Despite using the comparator that would determine a nullish topologyVersion as greater than\n    // for equality we should only always perform direct equality comparison\n    const topologyVersionsEqual = this.topologyVersion === (other === null || other === void 0 ? void 0 : other.topologyVersion) || compareTopologyVersion(this.topologyVersion, other === null || other === void 0 ? void 0 : other.topologyVersion) === 0;\n    const electionIdsEqual = this.electionId != null && (other === null || other === void 0 ? void 0 : other.electionId) != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === (other === null || other === void 0 ? void 0 : other.electionId);\n    return other != null && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;\n  }\n\n}\n\nexports.ServerDescription = ServerDescription; // Parses a `hello` message and determines the server type\n\nfunction parseServerType(hello, options) {\n  if (options === null || options === void 0 ? void 0 : options.loadBalanced) {\n    return common_1.ServerType.LoadBalancer;\n  }\n\n  if (!hello || !hello.ok) {\n    return common_1.ServerType.Unknown;\n  }\n\n  if (hello.isreplicaset) {\n    return common_1.ServerType.RSGhost;\n  }\n\n  if (hello.msg && hello.msg === 'isdbgrid') {\n    return common_1.ServerType.Mongos;\n  }\n\n  if (hello.setName) {\n    if (hello.hidden) {\n      return common_1.ServerType.RSOther;\n    } else if (hello.isWritablePrimary) {\n      return common_1.ServerType.RSPrimary;\n    } else if (hello.secondary) {\n      return common_1.ServerType.RSSecondary;\n    } else if (hello.arbiterOnly) {\n      return common_1.ServerType.RSArbiter;\n    } else {\n      return common_1.ServerType.RSOther;\n    }\n  }\n\n  return common_1.ServerType.Standalone;\n}\n\nexports.parseServerType = parseServerType;\n\nfunction tagsStrictEqual(tags, tags2) {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(key => tags2[key] === tags[key]);\n}\n/**\n * Compares two topology versions.\n *\n * 1. If the response topologyVersion is unset or the ServerDescription's\n *    topologyVersion is null, the client MUST assume the response is more recent.\n * 1. If the response's topologyVersion.processId is not equal to the\n *    ServerDescription's, the client MUST assume the response is more recent.\n * 1. If the response's topologyVersion.processId is equal to the\n *    ServerDescription's, the client MUST use the counter field to determine\n *    which topologyVersion is more recent.\n *\n * ```ts\n * currentTv <   newTv === -1\n * currentTv === newTv === 0\n * currentTv >   newTv === 1\n * ```\n */\n\n\nfunction compareTopologyVersion(currentTv, newTv) {\n  if (currentTv == null || newTv == null) {\n    return -1;\n  }\n\n  if (!currentTv.processId.equals(newTv.processId)) {\n    return -1;\n  } // TODO(NODE-2674): Preserve int64 sent from MongoDB\n\n\n  const currentCounter = bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);\n  const newCounter = bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);\n  return currentCounter.compare(newCounter);\n}\n\nexports.compareTopologyVersion = compareTopologyVersion;","map":{"version":3,"mappings":"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","names":["WRITABLE_SERVER_TYPES","Set","common_1","RSPrimary","Standalone","Mongos","LoadBalancer","DATA_BEARING_SERVER_TYPES","RSSecondary","ServerDescription","constructor","address","hello","options","error_1","utils_1","fromString","toString","type","parseServerType","hosts","_a","map","host","toLowerCase","_b","passives","_c","_d","arbiters","_e","_f","tags","_g","minWireVersion","_h","maxWireVersion","_j","roundTripTime","_k","lastUpdateTime","lastWriteDate","lastWrite","_l","_m","error","_o","topologyVersion","_p","_q","_r","setName","_s","setVersion","_t","electionId","_u","logicalSessionTimeoutMinutes","_v","primary","_w","me","_x","_y","$clusterTime","_z","hostAddress","allHosts","concat","isReadable","isWritable","isDataBearing","has","chopLength","port","length","slice","split","pop","Number","parseInt","equals","other","topologyVersionsEqual","compareTopologyVersion","electionIdsEqual","tagsStrictEqual","exports","loadBalanced","ok","Unknown","isreplicaset","RSGhost","msg","hidden","RSOther","isWritablePrimary","secondary","arbiterOnly","RSArbiter","tags2","tagsKeys","Object","keys","tags2Keys","every","key","currentTv","newTv","processId","currentCounter","bson_1","isLong","counter","fromNumber","newCounter","compare"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\sdam\\server_description.ts"],"sourcesContent":["import { Document, Long, ObjectId } from '../bson';\nimport { MongoError, MongoRuntimeError, MongoServerError } from '../error';\nimport { arrayStrictEqual, compareObjectId, errorStrictEqual, HostAddress, now } from '../utils';\nimport type { ClusterTime } from './common';\nimport { ServerType } from './common';\n\nconst WRITABLE_SERVER_TYPES = new Set<ServerType>([\n  ServerType.RSPrimary,\n  ServerType.Standalone,\n  ServerType.Mongos,\n  ServerType.LoadBalancer\n]);\n\nconst DATA_BEARING_SERVER_TYPES = new Set<ServerType>([\n  ServerType.RSPrimary,\n  ServerType.RSSecondary,\n  ServerType.Mongos,\n  ServerType.Standalone,\n  ServerType.LoadBalancer\n]);\n\n/** @public */\nexport interface TopologyVersion {\n  processId: ObjectId;\n  counter: Long;\n}\n\n/** @public */\nexport type TagSet = { [key: string]: string };\n\n/** @internal */\nexport interface ServerDescriptionOptions {\n  /** An Error used for better reporting debugging */\n  error?: MongoServerError;\n\n  /** The round trip time to ping this server (in ms) */\n  roundTripTime?: number;\n\n  /** If the client is in load balancing mode. */\n  loadBalanced?: boolean;\n}\n\n/**\n * The client's view of a single server, based on the most recent hello outcome.\n *\n * Internal type, not meant to be directly instantiated\n * @public\n */\nexport class ServerDescription {\n  address: string;\n  type: ServerType;\n  hosts: string[];\n  passives: string[];\n  arbiters: string[];\n  tags: TagSet;\n  error: MongoError | null;\n  topologyVersion: TopologyVersion | null;\n  minWireVersion: number;\n  maxWireVersion: number;\n  roundTripTime: number;\n  lastUpdateTime: number;\n  lastWriteDate: number;\n  me: string | null;\n  primary: string | null;\n  setName: string | null;\n  setVersion: number | null;\n  electionId: ObjectId | null;\n  logicalSessionTimeoutMinutes: number | null;\n\n  // NOTE: does this belong here? It seems we should gossip the cluster time at the CMAP level\n  $clusterTime?: ClusterTime;\n\n  /**\n   * Create a ServerDescription\n   * @internal\n   *\n   * @param address - The address of the server\n   * @param hello - An optional hello response for this server\n   */\n  constructor(\n    address: HostAddress | string,\n    hello?: Document,\n    options: ServerDescriptionOptions = {}\n  ) {\n    if (address == null || address === '') {\n      throw new MongoRuntimeError('ServerDescription must be provided with a non-empty address');\n    }\n\n    this.address =\n      typeof address === 'string'\n        ? HostAddress.fromString(address).toString() // Use HostAddress to normalize\n        : address.toString();\n    this.type = parseServerType(hello, options);\n    this.hosts = hello?.hosts?.map((host: string) => host.toLowerCase()) ?? [];\n    this.passives = hello?.passives?.map((host: string) => host.toLowerCase()) ?? [];\n    this.arbiters = hello?.arbiters?.map((host: string) => host.toLowerCase()) ?? [];\n    this.tags = hello?.tags ?? {};\n    this.minWireVersion = hello?.minWireVersion ?? 0;\n    this.maxWireVersion = hello?.maxWireVersion ?? 0;\n    this.roundTripTime = options?.roundTripTime ?? -1;\n    this.lastUpdateTime = now();\n    this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;\n    this.error = options.error ?? null;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    this.topologyVersion = this.error?.topologyVersion ?? hello?.topologyVersion ?? null;\n    this.setName = hello?.setName ?? null;\n    this.setVersion = hello?.setVersion ?? null;\n    this.electionId = hello?.electionId ?? null;\n    this.logicalSessionTimeoutMinutes = hello?.logicalSessionTimeoutMinutes ?? null;\n    this.primary = hello?.primary ?? null;\n    this.me = hello?.me?.toLowerCase() ?? null;\n    this.$clusterTime = hello?.$clusterTime ?? null;\n  }\n\n  get hostAddress(): HostAddress {\n    return HostAddress.fromString(this.address);\n  }\n\n  get allHosts(): string[] {\n    return this.hosts.concat(this.arbiters).concat(this.passives);\n  }\n\n  /** Is this server available for reads*/\n  get isReadable(): boolean {\n    return this.type === ServerType.RSSecondary || this.isWritable;\n  }\n\n  /** Is this server data bearing */\n  get isDataBearing(): boolean {\n    return DATA_BEARING_SERVER_TYPES.has(this.type);\n  }\n\n  /** Is this server available for writes */\n  get isWritable(): boolean {\n    return WRITABLE_SERVER_TYPES.has(this.type);\n  }\n\n  get host(): string {\n    const chopLength = `:${this.port}`.length;\n    return this.address.slice(0, -chopLength);\n  }\n\n  get port(): number {\n    const port = this.address.split(':').pop();\n    return port ? Number.parseInt(port, 10) : 27017;\n  }\n\n  /**\n   * Determines if another `ServerDescription` is equal to this one per the rules defined\n   * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}\n   */\n  equals(other?: ServerDescription | null): boolean {\n    // Despite using the comparator that would determine a nullish topologyVersion as greater than\n    // for equality we should only always perform direct equality comparison\n    const topologyVersionsEqual =\n      this.topologyVersion === other?.topologyVersion ||\n      compareTopologyVersion(this.topologyVersion, other?.topologyVersion) === 0;\n\n    const electionIdsEqual =\n      this.electionId != null && other?.electionId != null\n        ? compareObjectId(this.electionId, other.electionId) === 0\n        : this.electionId === other?.electionId;\n\n    return (\n      other != null &&\n      errorStrictEqual(this.error, other.error) &&\n      this.type === other.type &&\n      this.minWireVersion === other.minWireVersion &&\n      arrayStrictEqual(this.hosts, other.hosts) &&\n      tagsStrictEqual(this.tags, other.tags) &&\n      this.setName === other.setName &&\n      this.setVersion === other.setVersion &&\n      electionIdsEqual &&\n      this.primary === other.primary &&\n      this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes &&\n      topologyVersionsEqual\n    );\n  }\n}\n\n// Parses a `hello` message and determines the server type\nexport function parseServerType(hello?: Document, options?: ServerDescriptionOptions): ServerType {\n  if (options?.loadBalanced) {\n    return ServerType.LoadBalancer;\n  }\n\n  if (!hello || !hello.ok) {\n    return ServerType.Unknown;\n  }\n\n  if (hello.isreplicaset) {\n    return ServerType.RSGhost;\n  }\n\n  if (hello.msg && hello.msg === 'isdbgrid') {\n    return ServerType.Mongos;\n  }\n\n  if (hello.setName) {\n    if (hello.hidden) {\n      return ServerType.RSOther;\n    } else if (hello.isWritablePrimary) {\n      return ServerType.RSPrimary;\n    } else if (hello.secondary) {\n      return ServerType.RSSecondary;\n    } else if (hello.arbiterOnly) {\n      return ServerType.RSArbiter;\n    } else {\n      return ServerType.RSOther;\n    }\n  }\n\n  return ServerType.Standalone;\n}\n\nfunction tagsStrictEqual(tags: TagSet, tags2: TagSet): boolean {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n\n  return (\n    tagsKeys.length === tags2Keys.length &&\n    tagsKeys.every((key: string) => tags2[key] === tags[key])\n  );\n}\n\n/**\n * Compares two topology versions.\n *\n * 1. If the response topologyVersion is unset or the ServerDescription's\n *    topologyVersion is null, the client MUST assume the response is more recent.\n * 1. If the response's topologyVersion.processId is not equal to the\n *    ServerDescription's, the client MUST assume the response is more recent.\n * 1. If the response's topologyVersion.processId is equal to the\n *    ServerDescription's, the client MUST use the counter field to determine\n *    which topologyVersion is more recent.\n *\n * ```ts\n * currentTv <   newTv === -1\n * currentTv === newTv === 0\n * currentTv >   newTv === 1\n * ```\n */\nexport function compareTopologyVersion(\n  currentTv?: TopologyVersion | null,\n  newTv?: TopologyVersion | null\n): 0 | -1 | 1 {\n  if (currentTv == null || newTv == null) {\n    return -1;\n  }\n\n  if (!currentTv.processId.equals(newTv.processId)) {\n    return -1;\n  }\n\n  // TODO(NODE-2674): Preserve int64 sent from MongoDB\n  const currentCounter = Long.isLong(currentTv.counter)\n    ? currentTv.counter\n    : Long.fromNumber(currentTv.counter);\n  const newCounter = Long.isLong(newTv.counter) ? newTv.counter : Long.fromNumber(newTv.counter);\n\n  return currentCounter.compare(newCounter);\n}\n"]},"metadata":{},"sourceType":"script"}