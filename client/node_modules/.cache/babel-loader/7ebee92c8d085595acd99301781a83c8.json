{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;\n\nconst zlib = require(\"zlib\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n/** @public */\n\n\nexports.Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n});\nexports.uncompressibleCommands = new Set([constants_1.LEGACY_HELLO_COMMAND, 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']);\nconst MAX_COMPRESSOR_ID = 3;\nconst ZSTD_COMPRESSION_LEVEL = 3; // Facilitate compressing a message using an agreed compressor\n\nfunction compress(self, dataToBeCompressed, callback) {\n  const zlibOptions = {};\n\n  switch (self.options.agreedCompressor) {\n    case 'snappy':\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.compress(dataToBeCompressed, callback);\n        } else {\n          deps_1.Snappy.compress(dataToBeCompressed).then(buffer => callback(undefined, buffer), error => callback(error));\n        }\n\n        break;\n      }\n\n    case 'zlib':\n      // Determine zlibCompressionLevel\n      if (self.options.zlibCompressionLevel) {\n        zlibOptions.level = self.options.zlibCompressionLevel;\n      }\n\n      zlib.deflate(dataToBeCompressed, zlibOptions, callback);\n      break;\n\n    case 'zstd':\n      if ('kModuleError' in deps_1.ZStandard) {\n        return callback(deps_1.ZStandard['kModuleError']);\n      }\n\n      deps_1.ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then(buffer => callback(undefined, buffer), error => callback(error));\n      break;\n\n    default:\n      throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${self.options.agreedCompressor} failed to compress`);\n  }\n}\n\nexports.compress = compress; // Decompress a message using the given compressor\n\nfunction decompress(compressorID, compressedData, callback) {\n  if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {\n    throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);\n  }\n\n  switch (compressorID) {\n    case exports.Compressor.snappy:\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }, callback);\n        } else {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }).then(buffer => callback(undefined, buffer), error => callback(error));\n        }\n\n        break;\n      }\n\n    case exports.Compressor.zstd:\n      {\n        if ('kModuleError' in deps_1.ZStandard) {\n          return callback(deps_1.ZStandard['kModuleError']);\n        }\n\n        deps_1.ZStandard.decompress(compressedData).then(buffer => callback(undefined, buffer), error => callback(error));\n        break;\n      }\n\n    case exports.Compressor.zlib:\n      zlib.inflate(compressedData, callback);\n      break;\n\n    default:\n      callback(undefined, compressedData);\n  }\n}\n\nexports.decompress = decompress;","map":{"version":3,"mappings":"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","names":["exports","Object","freeze","none","snappy","zlib","zstd","Set","constants_1","MAX_COMPRESSOR_ID","ZSTD_COMPRESSION_LEVEL","compress","self","dataToBeCompressed","callback","zlibOptions","options","agreedCompressor","deps_1","major","then","buffer","undefined","error","zlibCompressionLevel","level","deflate","error_1","decompress","compressorID","compressedData","uncompress","asBuffer","inflate"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\compression.ts"],"sourcesContent":["import * as zlib from 'zlib';\n\nimport { LEGACY_HELLO_COMMAND } from '../../constants';\nimport { PKG_VERSION, Snappy, ZStandard } from '../../deps';\nimport { MongoDecompressionError, MongoInvalidArgumentError } from '../../error';\nimport type { Callback } from '../../utils';\nimport type { OperationDescription } from '../message_stream';\n\n/** @public */\nexport const Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n} as const);\n\n/** @public */\nexport type Compressor = typeof Compressor[CompressorName];\n\n/** @public */\nexport type CompressorName = keyof typeof Compressor;\n\nexport const uncompressibleCommands = new Set([\n  LEGACY_HELLO_COMMAND,\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'authenticate',\n  'createUser',\n  'updateUser',\n  'copydbSaslStart',\n  'copydbgetnonce',\n  'copydb'\n]);\n\nconst MAX_COMPRESSOR_ID = 3;\nconst ZSTD_COMPRESSION_LEVEL = 3;\n\n// Facilitate compressing a message using an agreed compressor\nexport function compress(\n  self: { options: OperationDescription & zlib.ZlibOptions },\n  dataToBeCompressed: Buffer,\n  callback: Callback<Buffer>\n): void {\n  const zlibOptions = {} as zlib.ZlibOptions;\n  switch (self.options.agreedCompressor) {\n    case 'snappy': {\n      if ('kModuleError' in Snappy) {\n        return callback(Snappy['kModuleError']);\n      }\n\n      if (Snappy[PKG_VERSION].major <= 6) {\n        Snappy.compress(dataToBeCompressed, callback);\n      } else {\n        Snappy.compress(dataToBeCompressed).then(\n          buffer => callback(undefined, buffer),\n          error => callback(error)\n        );\n      }\n      break;\n    }\n    case 'zlib':\n      // Determine zlibCompressionLevel\n      if (self.options.zlibCompressionLevel) {\n        zlibOptions.level = self.options.zlibCompressionLevel;\n      }\n      zlib.deflate(dataToBeCompressed, zlibOptions, callback as zlib.CompressCallback);\n      break;\n    case 'zstd':\n      if ('kModuleError' in ZStandard) {\n        return callback(ZStandard['kModuleError']);\n      }\n      ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then(\n        buffer => callback(undefined, buffer),\n        error => callback(error)\n      );\n      break;\n    default:\n      throw new MongoInvalidArgumentError(\n        `Unknown compressor ${self.options.agreedCompressor} failed to compress`\n      );\n  }\n}\n\n// Decompress a message using the given compressor\nexport function decompress(\n  compressorID: Compressor,\n  compressedData: Buffer,\n  callback: Callback<Buffer>\n): void {\n  if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {\n    throw new MongoDecompressionError(\n      `Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`\n    );\n  }\n\n  switch (compressorID) {\n    case Compressor.snappy: {\n      if ('kModuleError' in Snappy) {\n        return callback(Snappy['kModuleError']);\n      }\n\n      if (Snappy[PKG_VERSION].major <= 6) {\n        Snappy.uncompress(compressedData, { asBuffer: true }, callback);\n      } else {\n        Snappy.uncompress(compressedData, { asBuffer: true }).then(\n          buffer => callback(undefined, buffer),\n          error => callback(error)\n        );\n      }\n      break;\n    }\n    case Compressor.zstd: {\n      if ('kModuleError' in ZStandard) {\n        return callback(ZStandard['kModuleError']);\n      }\n\n      ZStandard.decompress(compressedData).then(\n        buffer => callback(undefined, buffer),\n        error => callback(error)\n      );\n      break;\n    }\n    case Compressor.zlib:\n      zlib.inflate(compressedData, callback as zlib.CompressCallback);\n      break;\n    default:\n      callback(undefined, compressedData);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}