{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\n\nconst bson_1 = require(\"./bson\");\n\nconst ordered_1 = require(\"./bulk/ordered\");\n\nconst unordered_1 = require(\"./bulk/unordered\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\n\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\n\nconst list_indexes_cursor_1 = require(\"./cursor/list_indexes_cursor\");\n\nconst error_1 = require(\"./error\");\n\nconst bulk_write_1 = require(\"./operations/bulk_write\");\n\nconst count_1 = require(\"./operations/count\");\n\nconst count_documents_1 = require(\"./operations/count_documents\");\n\nconst delete_1 = require(\"./operations/delete\");\n\nconst distinct_1 = require(\"./operations/distinct\");\n\nconst drop_1 = require(\"./operations/drop\");\n\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\n\nconst indexes_1 = require(\"./operations/indexes\");\n\nconst insert_1 = require(\"./operations/insert\");\n\nconst is_capped_1 = require(\"./operations/is_capped\");\n\nconst map_reduce_1 = require(\"./operations/map_reduce\");\n\nconst options_operation_1 = require(\"./operations/options_operation\");\n\nconst rename_1 = require(\"./operations/rename\");\n\nconst stats_1 = require(\"./operations/stats\");\n\nconst update_1 = require(\"./operations/update\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst utils_1 = require(\"./utils\");\n\nconst write_concern_1 = require(\"./write_concern\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * interface Pet {\n *   name: string;\n *   kind: 'dog' | 'cat' | 'fish';\n * }\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const pets = client.db().collection<Pet>('pets');\n *\n * const petCursor = pets.find();\n *\n * for await (const pet of petCursor) {\n *   console.log(`${pet.name} is a ${pet.kind}!`);\n * }\n * ```\n */\n\n\nclass Collection {\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db, name, options) {\n    var _a, _b;\n\n    (0, utils_1.checkCollectionName)(name); // Internal state\n\n    this.s = {\n      db,\n      options,\n      namespace: new utils_1.MongoDBNamespace(db.databaseName, name),\n      pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n  }\n  /**\n   * The name of the database this collection belongs to\n   */\n\n\n  get dbName() {\n    return this.s.namespace.db;\n  }\n  /**\n   * The name of this collection\n   */\n\n\n  get collectionName() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.s.namespace.collection;\n  }\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n\n\n  get namespace() {\n    return this.s.namespace.toString();\n  }\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get readConcern() {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n\n    return this.s.readConcern;\n  }\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get readPreference() {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get writeConcern() {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n\n    return this.s.writeConcern;\n  }\n  /** The current index hint for the collection */\n\n\n  get hint() {\n    return this.s.collectionHint;\n  }\n\n  set hint(v) {\n    this.s.collectionHint = (0, utils_1.normalizeHintField)(v);\n  }\n\n  insertOne(doc, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } // versions of mongodb-client-encryption before v1.2.6 pass in hardcoded { w: 'majority' }\n    // specifically to an insertOne call in createDataKey, so we want to support this only here\n\n\n    if (options && Reflect.get(options, 'w')) {\n      options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));\n    }\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  insertMany(docs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {\n      ordered: true\n    };\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  bulkWrite(operations, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: true\n    };\n\n    if (!Array.isArray(operations)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n    }\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  updateOne(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  replaceOne(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  updateMany(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  deleteOne(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  deleteMany(filter, options, callback) {\n    if (filter == null) {\n      filter = {};\n      options = {};\n      callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  rename(newName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {}; // Intentionally, we do not inherit options from parent for this operation.\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new rename_1.RenameOperation(this, newName, { ...options,\n      readPreference: read_preference_1.ReadPreference.PRIMARY\n    }), callback);\n  }\n\n  drop(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);\n  }\n\n  findOne(filter, options, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Third parameter to `findOne()` must be a callback or undefined');\n    }\n\n    if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    }\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    const finalFilter = filter !== null && filter !== void 0 ? filter : {};\n    const finalOptions = options !== null && options !== void 0 ? options : {};\n    return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);\n  }\n\n  find(filter, options) {\n    if (arguments.length > 2) {\n      throw new error_1.MongoInvalidArgumentError('Method \"collection.find()\" accepts at most two arguments');\n    }\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new find_cursor_1.FindCursor(this.s.db.s.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));\n  }\n\n  options(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  isCapped(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  createIndex(indexSpec, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  createIndexes(indexSpecs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {};\n    if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  dropIndex(indexName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = (0, utils_1.resolveOptions)(this, options); // Run only against primary\n\n    options.readPreference = read_preference_1.ReadPreference.primary;\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexOperation(this, indexName, options), callback);\n  }\n\n  dropIndexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n\n\n  listIndexes(options) {\n    return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));\n  }\n\n  indexExists(indexes, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  indexInformation(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  estimatedDocumentCount(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  countDocuments(filter, options, callback) {\n    if (filter == null) {\n      filter = {}, options = {}, callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 2) {\n        if (typeof options === 'function') callback = options, options = {};\n      }\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  } // Implementation\n\n\n  distinct(key, filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 3 && typeof options === 'function') {\n        callback = options, options = {};\n      }\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  indexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  stats(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new stats_1.CollStatsOperation(this, options), callback);\n  }\n\n  findOneAndDelete(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  findOneAndReplace(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  findOneAndUpdate(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n\n\n  aggregate() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (arguments.length > 2) {\n      throw new error_1.MongoInvalidArgumentError('Method \"collection.aggregate()\" accepts at most two arguments');\n    }\n\n    if (!Array.isArray(pipeline)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n    }\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new aggregation_cursor_1.AggregationCursor(this.s.db.s.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to override the schema that may be defined for this specific collection\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   * @example\n   * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n   * ```ts\n   * collection.watch<{ _id: number }>()\n   *   .on('change', change => console.log(change._id.toFixed(4)));\n   * ```\n   *\n   * @example\n   * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n   * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n   * No need start from scratch on the ChangeStreamInsertDocument type!\n   * By using an intersection we can save time and ensure defaults remain the same type!\n   * ```ts\n   * collection\n   *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n   *     { $addFields: { comment: 'big changes' } },\n   *     { $match: { operationType: 'insert' } }\n   *   ])\n   *   .on('change', change => {\n   *     change.comment.startsWith('big');\n   *     change.operationType === 'insert';\n   *     // No need to narrow in code because the generics did that for us!\n   *     expectType<Schema>(change.fullDocument);\n   *   });\n   * ```\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TLocal - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n\n\n  watch() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n\n  mapReduce(map, reduce, options, callback) {\n    (0, utils_1.emitWarningOnce)('collection.mapReduce is deprecated. Use the aggregation pipeline instead. Visit https://docs.mongodb.com/manual/reference/map-reduce-to-aggregation-pipeline for more information on how to translate map-reduce operations to the aggregation pipeline.');\n    if ('function' === typeof options) callback = options, options = {}; // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n    // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n\n    if ((options === null || options === void 0 ? void 0 : options.out) == null) {\n      throw new error_1.MongoInvalidArgumentError('Option \"out\" must be defined, see mongodb docs for possible values');\n    }\n\n    if ('function' === typeof map) {\n      map = map.toString();\n    }\n\n    if ('function' === typeof reduce) {\n      reduce = reduce.toString();\n    }\n\n    if ('function' === typeof options.finalize) {\n      options.finalize = options.finalize.toString();\n    }\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new map_reduce_1.MapReduceOperation(this, map, reduce, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n  /**\n   * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n\n\n  initializeUnorderedBulkOp(options) {\n    return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n\n\n  initializeOrderedBulkOp(options) {\n    return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /** Get the db scoped logger */\n\n\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n\n  get logger() {\n    return this.s.db.s.logger;\n  }\n  /**\n   * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @deprecated Use insertOne, insertMany or bulkWrite instead. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  insert(docs, options, callback) {\n    (0, utils_1.emitWarningOnce)('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: false\n    };\n    docs = !Array.isArray(docs) ? [docs] : docs;\n\n    if (options.keepGoing === true) {\n      options.ordered = false;\n    }\n\n    return this.insertMany(docs, options, callback);\n  }\n  /**\n   * Updates documents.\n   *\n   * @deprecated use updateOne, updateMany or bulkWrite. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance\n   * @param filter - The filter for the update operation.\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  update(filter, update, options, callback) {\n    (0, utils_1.emitWarningOnce)('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.updateMany(filter, update, options, callback);\n  }\n  /**\n   * Remove documents.\n   *\n   * @deprecated use deleteOne, deleteMany or bulkWrite. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance\n   * @param filter - The filter for the remove operation.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  remove(filter, options, callback) {\n    (0, utils_1.emitWarningOnce)('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.deleteMany(filter, options, callback);\n  }\n\n  count(filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (typeof options === 'function') callback = options, options = {};\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_1.CountOperation(utils_1.MongoDBNamespace.fromString(this.namespace), filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n}\n\nexports.Collection = Collection;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAaA;;AAEA;;AACA;;AACA;;AAMA;;AACA;;AACA;;AAIA;;AAEA;;AAQA;;AAcA;;AAOA;;AACA;;AAOA;;AACA;;AACA;;AACA;;AAQA;;AACA;;AACA;;AASA;AA0CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,MAAaA,UAAb,CAAuB;EAIrB;;;;EAIAC,YAAYC,EAAZ,EAAoBC,IAApB,EAAkCC,OAAlC,EAA6D;;;IAC3D,iCAAoBD,IAApB,EAD2D,CAG3D;;IACA,KAAKE,CAAL,GAAS;MACPH,EADO;MAEPE,OAFO;MAGPE,SAAS,EAAE,IAAIC,wBAAJ,CAAqBL,EAAE,CAACM,YAAxB,EAAsCL,IAAtC,CAHJ;MAIPM,SAAS,EAAE,cAAE,CAACL,OAAH,MAAU,IAAV,IAAUM,aAAV,GAAU,MAAV,GAAUA,GAAED,SAAZ,MAAqB,IAArB,IAAqBE,aAArB,GAAqBA,EAArB,GAAyBJ,0BAJ7B;MAKPK,cAAc,EAAEC,iCAAeC,WAAf,CAA2BV,OAA3B,CALT;MAMPW,WAAW,EAAE,+BAAmBX,OAAnB,EAA4BF,EAA5B,CANN;MAOPc,WAAW,EAAEC,2BAAYH,WAAZ,CAAwBV,OAAxB,CAPN;MAQPc,YAAY,EAAEC,6BAAaL,WAAb,CAAyBV,OAAzB;IARP,CAAT;EAUD;EAED;;;;;EAGU,IAANgB,MAAM;IACR,OAAO,KAAKf,CAAL,CAAOC,SAAP,CAAiBJ,EAAxB;EACD;EAED;;;;;EAGkB,IAAdmB,cAAc;IAChB;IACA,OAAO,KAAKhB,CAAL,CAAOC,SAAP,CAAiBgB,UAAxB;EACD;EAED;;;;;EAGa,IAAThB,SAAS;IACX,OAAO,KAAKD,CAAL,CAAOC,SAAP,CAAiBiB,QAAjB,EAAP;EACD;EAED;;;;;;EAIe,IAAXP,WAAW;IACb,IAAI,KAAKX,CAAL,CAAOW,WAAP,IAAsB,IAA1B,EAAgC;MAC9B,OAAO,KAAKX,CAAL,CAAOH,EAAP,CAAUc,WAAjB;IACD;;IACD,OAAO,KAAKX,CAAL,CAAOW,WAAd;EACD;EAED;;;;;;EAIkB,IAAdJ,cAAc;IAChB,IAAI,KAAKP,CAAL,CAAOO,cAAP,IAAyB,IAA7B,EAAmC;MACjC,OAAO,KAAKP,CAAL,CAAOH,EAAP,CAAUU,cAAjB;IACD;;IAED,OAAO,KAAKP,CAAL,CAAOO,cAAd;EACD;;EAEc,IAAXG,WAAW;IACb,OAAO,KAAKV,CAAL,CAAOU,WAAd;EACD;EAED;;;;;;EAIgB,IAAZG,YAAY;IACd,IAAI,KAAKb,CAAL,CAAOa,YAAP,IAAuB,IAA3B,EAAiC;MAC/B,OAAO,KAAKb,CAAL,CAAOH,EAAP,CAAUgB,YAAjB;IACD;;IACD,OAAO,KAAKb,CAAL,CAAOa,YAAd;EACD;EAED;;;EACQ,IAAJM,IAAI;IACN,OAAO,KAAKnB,CAAL,CAAOoB,cAAd;EACD;;EAEO,IAAJD,IAAI,CAACE,CAAD,EAAoB;IAC1B,KAAKrB,CAAL,CAAOoB,cAAP,GAAwB,gCAAmBC,CAAnB,CAAxB;EACD;;EA2BDC,SAAS,CACPC,GADO,EAEPxB,OAFO,EAGPyB,QAHO,EAGsC;IAE7C,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAmC;MACjCyB,QAAQ,GAAGzB,OAAX;MACAA,OAAO,GAAG,EAAV;IACD,CAL4C,CAO7C;IACA;;;IACA,IAAIA,OAAO,IAAI0B,OAAO,CAACC,GAAR,CAAY3B,OAAZ,EAAqB,GAArB,CAAf,EAA0C;MACxCA,OAAO,CAACc,YAAR,GAAuBC,6BAAaL,WAAb,CAAyBgB,OAAO,CAACC,GAAR,CAAY3B,OAAZ,EAAqB,GAArB,CAAzB,CAAvB;IACD;;IAED,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIC,2BAAJ,CACE,IADF,EAEEL,GAFF,EAGE,4BAAe,IAAf,EAAqBxB,OAArB,CAHF,CAFK,EAOLyB,QAPK,CAAP;EASD;;EA2BDK,UAAU,CACRC,IADQ,EAER/B,OAFQ,EAGRyB,QAHQ,EAGsC;IAE9C,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAGA,OAAO,GAAGgC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBjC,OAAlB,CAAH,GAAgC;MAAEkC,OAAO,EAAE;IAAX,CAAjD;IAEA,OAAO,0CACL,KAAKjC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIC,4BAAJ,CACE,IADF,EAEEE,IAFF,EAGE,4BAAe,IAAf,EAAqB/B,OAArB,CAHF,CAFK,EAOLyB,QAPK,CAAP;EASD;;EAwCDU,SAAS,CACPC,UADO,EAEPpC,OAFO,EAGPyB,QAHO,EAG6B;IAEpC,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAGA,OAAO,IAAI;MAAEkC,OAAO,EAAE;IAAX,CAArB;;IAEA,IAAI,CAACG,KAAK,CAACC,OAAN,CAAcF,UAAd,CAAL,EAAgC;MAC9B,MAAM,IAAIG,iCAAJ,CAA8B,qDAA9B,CAAN;IACD;;IAED,OAAO,0CACL,KAAKtC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIY,+BAAJ,CACE,IADF,EAEEJ,UAFF,EAGE,4BAAe,IAAf,EAAqBpC,OAArB,CAHF,CAFK,EAOLyB,QAPK,CAAP;EASD;;EAgCDgB,SAAS,CACPC,MADO,EAEPC,MAFO,EAGP3C,OAHO,EAIPyB,QAJO,EAI0B;IAEjC,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIgB,2BAAJ,CACE,IADF,EAEEF,MAFF,EAGEC,MAHF,EAIE,4BAAe,IAAf,EAAqB3C,OAArB,CAJF,CAFK,EAQLyB,QARK,CAAP;EAUD;;EAgCDoB,UAAU,CACRH,MADQ,EAERI,WAFQ,EAGR9C,OAHQ,EAIRyB,QAJQ,EAIoC;IAE5C,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIgB,4BAAJ,CACE,IADF,EAEEF,MAFF,EAGEI,WAHF,EAIE,4BAAe,IAAf,EAAqB9C,OAArB,CAJF,CAFK,EAQLyB,QARK,CAAP;EAUD;;EAgCDsB,UAAU,CACRL,MADQ,EAERC,MAFQ,EAGR3C,OAHQ,EAIRyB,QAJQ,EAIoC;IAE5C,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIgB,4BAAJ,CACE,IADF,EAEEF,MAFF,EAGEC,MAHF,EAIE,4BAAe,IAAf,EAAqB3C,OAArB,CAJF,CAFK,EAQLyB,QARK,CAAP;EAUD;;EAmBDuB,SAAS,CACPN,MADO,EAEP1C,OAFO,EAGPyB,QAHO,EAG0B;IAEjC,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIqB,2BAAJ,CAAuB,IAAvB,EAA+CP,MAA/C,EAAuD,4BAAe,IAAf,EAAqB1C,OAArB,CAAvD,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAmBDyB,UAAU,CACRR,MADQ,EAER1C,OAFQ,EAGRyB,QAHQ,EAGyB;IAEjC,IAAIiB,MAAM,IAAI,IAAd,EAAoB;MAClBA,MAAM,GAAG,EAAT;MACA1C,OAAO,GAAG,EAAV;MACAyB,QAAQ,GAAG0B,SAAX;IACD,CAJD,MAIO,IAAI,OAAOT,MAAP,KAAkB,UAAtB,EAAkC;MACvCjB,QAAQ,GAAGiB,MAAX;MACAA,MAAM,GAAG,EAAT;MACA1C,OAAO,GAAG,EAAV;IACD,CAJM,MAIA,IAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAmC;MACxCyB,QAAQ,GAAGzB,OAAX;MACAA,OAAO,GAAG,EAAV;IACD;;IAED,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIqB,4BAAJ,CAAwB,IAAxB,EAAgDP,MAAhD,EAAwD,4BAAe,IAAf,EAAqB1C,OAArB,CAAxD,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAkBD2B,MAAM,CACJC,OADI,EAEJrD,OAFI,EAGJyB,QAHI,EAG2B;IAE/B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC,CAFJ,CAI/B;;IACA,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI0B,wBAAJ,CAAoB,IAApB,EAA4CD,OAA5C,EAAqD,EACnD,GAAGrD,OADgD;MAEnDQ,cAAc,EAAEC,iCAAe8C;IAFoB,CAArD,CAFK,EAML9B,QANK,CAAP;EAQD;;EAcD+B,IAAI,CACFxD,OADE,EAEFyB,QAFE,EAE0B;IAE5B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAGA,OAAO,SAAP,WAAO,WAAP,aAAW,EAArB;IAEA,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI6B,8BAAJ,CAA4B,KAAKxD,CAAL,CAAOH,EAAnC,EAAuC,KAAKmB,cAA5C,EAA4DjB,OAA5D,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAoCDiC,OAAO,CACLhB,MADK,EAEL1C,OAFK,EAGLyB,QAHK,EAGsC;IAE3C,IAAIA,QAAQ,IAAI,IAAZ,IAAoB,OAAOA,QAAP,KAAoB,UAA5C,EAAwD;MACtD,MAAM,IAAIc,iCAAJ,CACJ,gEADI,CAAN;IAGD;;IAED,IAAI,OAAOG,MAAP,KAAkB,UAAtB,EAAkC;MAChCjB,QAAQ,GAAGiB,MAAX;MACAA,MAAM,GAAG,EAAT;MACA1C,OAAO,GAAG,EAAV;IACD;;IACD,IAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAmC;MACjCyB,QAAQ,GAAGzB,OAAX;MACAA,OAAO,GAAG,EAAV;IACD;;IAED,MAAM2D,WAAW,GAAGjB,MAAM,SAAN,UAAM,WAAN,YAAU,EAA9B;IACA,MAAMkB,YAAY,GAAG5D,OAAO,SAAP,WAAO,WAAP,aAAW,EAAhC;IACA,OAAO,KAAK6D,IAAL,CAAUF,WAAV,EAAuBC,YAAvB,EAAqCE,KAArC,CAA2C,CAAC,CAA5C,EAA+CC,SAA/C,CAAyD,CAAzD,EAA4DC,IAA5D,CAAiEvC,QAAjE,CAAP;EACD;;EAUDoC,IAAI,CAACnB,MAAD,EAA2B1C,OAA3B,EAAgD;IAClD,IAAIiE,SAAS,CAACC,MAAV,GAAmB,CAAvB,EAA0B;MACxB,MAAM,IAAI3B,iCAAJ,CACJ,0DADI,CAAN;IAGD;;IACD,IAAI,OAAOvC,OAAP,KAAmB,UAAvB,EAAmC;MACjC,MAAM,IAAIuC,iCAAJ,CAA8B,yCAA9B,CAAN;IACD;;IAED,OAAO,IAAI4B,wBAAJ,CACL,KAAKlE,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,KAAK3B,CAAL,CAAOC,SAFF,EAGLwC,MAHK,EAIL,4BAAe,IAAf,EAAuC1C,OAAvC,CAJK,CAAP;EAMD;;EAcDA,OAAO,CACLA,OADK,EAELyB,QAFK,EAEwB;IAE7B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIwC,oCAAJ,CAAqB,IAArB,EAA6C,4BAAe,IAAf,EAAqBpE,OAArB,CAA7C,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAcD4C,QAAQ,CACNrE,OADM,EAENyB,QAFM,EAEsB;IAE5B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI0C,6BAAJ,CAAsB,IAAtB,EAA8C,4BAAe,IAAf,EAAqBtE,OAArB,CAA9C,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAyCD8C,WAAW,CACTC,SADS,EAETxE,OAFS,EAGTyB,QAHS,EAGkB;IAE3B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI6C,8BAAJ,CACE,IADF,EAEE,KAAKxD,cAFP,EAGEuD,SAHF,EAIE,4BAAe,IAAf,EAAqBxE,OAArB,CAJF,CAFK,EAQLyB,QARK,CAAP;EAUD;;EA4CDiD,aAAa,CACXC,UADW,EAEX3E,OAFW,EAGXyB,QAHW,EAGkB;IAE7B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAGA,OAAO,GAAGgC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBjC,OAAlB,CAAH,GAAgC,EAAjD;IACA,IAAI,OAAOA,OAAO,CAAC4E,SAAf,KAA6B,QAAjC,EAA2C,OAAO5E,OAAO,CAAC4E,SAAf;IAE3C,OAAO,0CACL,KAAK3E,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI6C,gCAAJ,CACE,IADF,EAEE,KAAKxD,cAFP,EAGE0D,UAHF,EAIE,4BAAe,IAAf,EAAqB3E,OAArB,CAJF,CAFK,EAQLyB,QARK,CAAP;EAUD;;EAeDoD,SAAS,CACPC,SADO,EAEP9E,OAFO,EAGPyB,QAHO,EAGsB;IAE7B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAG,4BAAe,IAAf,EAAqBA,OAArB,CAAV,CAH6B,CAK7B;;IACAA,OAAO,CAACQ,cAAR,GAAyBC,iCAAesE,OAAxC;IAEA,OAAO,0CACL,KAAK9E,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI6C,4BAAJ,CAAuB,IAAvB,EAA+CK,SAA/C,EAA0D9E,OAA1D,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAcDuD,WAAW,CACThF,OADS,EAETyB,QAFS,EAEoB;IAE7B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI6C,8BAAJ,CAAyB,IAAzB,EAAiD,4BAAe,IAAf,EAAqBzE,OAArB,CAAjD,CAFK,EAGLyB,QAHK,CAAP;EAKD;EAED;;;;;;;EAKAwD,WAAW,CAACjF,OAAD,EAA6B;IACtC,OAAO,IAAIkF,uCAAJ,CAAsB,IAAtB,EAA8C,4BAAe,IAAf,EAAqBlF,OAArB,CAA9C,CAAP;EACD;;EAmBDmF,WAAW,CACTC,OADS,EAETpF,OAFS,EAGTyB,QAHS,EAGmB;IAE5B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI6C,8BAAJ,CAAyB,IAAzB,EAAiDW,OAAjD,EAA0D,4BAAe,IAAf,EAAqBpF,OAArB,CAA1D,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAcD4D,gBAAgB,CACdrF,OADc,EAEdyB,QAFc,EAEe;IAE7B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI6C,mCAAJ,CAA8B,KAAKxE,CAAL,CAAOH,EAArC,EAAyC,KAAKmB,cAA9C,EAA8D,4BAAe,IAAf,EAAqBjB,OAArB,CAA9D,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAsBD6D,sBAAsB,CACpBtF,OADoB,EAEpByB,QAFoB,EAEO;IAE3B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI2D,0DAAJ,CAAoC,IAApC,EAA4D,4BAAe,IAAf,EAAqBvF,OAArB,CAA5D,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAyCD+D,cAAc,CACZ9C,MADY,EAEZ1C,OAFY,EAGZyB,QAHY,EAGe;IAE3B,IAAIiB,MAAM,IAAI,IAAd,EAAoB;MACjBA,MAAM,GAAG,EAAV,EAAgB1C,OAAO,GAAG,EAA1B,EAAgCyB,QAAQ,GAAG0B,SAA3C;IACD,CAFD,MAEO,IAAI,OAAOT,MAAP,KAAkB,UAAtB,EAAkC;MACtCjB,QAAQ,GAAGiB,MAAZ,EAA0CA,MAAM,GAAG,EAAnD,EAAyD1C,OAAO,GAAG,EAAnE;IACD,CAFM,MAEA;MACL,IAAIiE,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;QAC1B,IAAI,OAAOlE,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;MACpC;IACF;;IAED0C,MAAM,SAAN,UAAM,WAAN,kBAAM,GAAK,EAAX;IACA,OAAO,0CACL,KAAKzC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI6D,yCAAJ,CACE,IADF,EAEE/C,MAFF,EAGE,4BAAe,IAAf,EAAqB1C,OAArB,CAHF,CAFK,EAOLyB,QAPK,CAAP;EASD,CA/+BoB,CAuiCrB;;;EACAiE,QAAQ,CACNC,GADM,EAENjD,MAFM,EAGN1C,OAHM,EAINyB,QAJM,EAIoB;IAE1B,IAAI,OAAOiB,MAAP,KAAkB,UAAtB,EAAkC;MAC/BjB,QAAQ,GAAGiB,MAAZ,EAAsBA,MAAM,GAAG,EAA/B,EAAqC1C,OAAO,GAAG,EAA/C;IACD,CAFD,MAEO;MACL,IAAIiE,SAAS,CAACC,MAAV,KAAqB,CAArB,IAA0B,OAAOlE,OAAP,KAAmB,UAAjD,EAA6D;QAC1DyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;MACD;IACF;;IAED0C,MAAM,SAAN,UAAM,WAAN,kBAAM,GAAK,EAAX;IACA,OAAO,0CACL,KAAKzC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIgE,4BAAJ,CACE,IADF,EAEED,GAFF,EAGEjD,MAHF,EAIE,4BAAe,IAAf,EAAqB1C,OAArB,CAJF,CAFK,EAQLyB,QARK,CAAP;EAUD;;EAcD2D,OAAO,CACLpF,OADK,EAELyB,QAFK,EAE0B;IAE/B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI6C,0BAAJ,CAAqB,IAArB,EAA6C,4BAAe,IAAf,EAAqBzE,OAArB,CAA7C,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAcDoE,KAAK,CACH7F,OADG,EAEHyB,QAFG,EAE2B;IAE9B,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAGA,OAAO,SAAP,WAAO,WAAP,aAAW,EAArB;IAEA,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIkE,0BAAJ,CAAuB,IAAvB,EAA+C9F,OAA/C,CAFK,EAGLyB,QAHK,CAAP;EAKD;;EAsBDsE,gBAAgB,CACdrD,MADc,EAEd1C,OAFc,EAGdyB,QAHc,EAG4B;IAE1C,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIoE,2CAAJ,CACE,IADF,EAEEtD,MAFF,EAGE,4BAAe,IAAf,EAAqB1C,OAArB,CAHF,CAFK,EAOLyB,QAPK,CAAP;EASD;;EAgCDwE,iBAAiB,CACfvD,MADe,EAEfI,WAFe,EAGf9C,OAHe,EAIfyB,QAJe,EAI2B;IAE1C,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIoE,4CAAJ,CACE,IADF,EAEEtD,MAFF,EAGEI,WAHF,EAIE,4BAAe,IAAf,EAAqB9C,OAArB,CAJF,CAFK,EAQLyB,QARK,CAAP;EAUD;;EAgCDyE,gBAAgB,CACdxD,MADc,EAEdC,MAFc,EAGd3C,OAHc,EAIdyB,QAJc,EAI4B;IAE1C,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IAEnC,OAAO,0CACL,KAAKC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIoE,2CAAJ,CACE,IADF,EAEEtD,MAFF,EAGEC,MAHF,EAIE,4BAAe,IAAf,EAAqB3C,OAArB,CAJF,CAFK,EAQLyB,QARK,CAAP;EAUD;EAED;;;;;;;;EAMA0E,SAAS,GAEmB;IAAA,IAD1BC,QAC0B,uEADH,EACG;IAAA,IAA1BpG,OAA0B;;IAE1B,IAAIiE,SAAS,CAACC,MAAV,GAAmB,CAAvB,EAA0B;MACxB,MAAM,IAAI3B,iCAAJ,CACJ,+DADI,CAAN;IAGD;;IACD,IAAI,CAACF,KAAK,CAACC,OAAN,CAAc8D,QAAd,CAAL,EAA8B;MAC5B,MAAM,IAAI7D,iCAAJ,CACJ,4DADI,CAAN;IAGD;;IACD,IAAI,OAAOvC,OAAP,KAAmB,UAAvB,EAAmC;MACjC,MAAM,IAAIuC,iCAAJ,CAA8B,yCAA9B,CAAN;IACD;;IAED,OAAO,IAAI8D,sCAAJ,CACL,KAAKpG,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,KAAK3B,CAAL,CAAOC,SAFF,EAGLkG,QAHK,EAIL,4BAAe,IAAf,EAAqBpG,OAArB,CAJK,CAAP;EAMD;EAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsCAsG,KAAK,GAE8B;IAAA,IADjCF,QACiC,uEADV,EACU;IAAA,IAAjCpG,OAAiC,uEAAF,EAAE;;IAEjC;IACA,IAAI,CAACqC,KAAK,CAACC,OAAN,CAAc8D,QAAd,CAAL,EAA8B;MAC5BpG,OAAO,GAAGoG,QAAV;MACAA,QAAQ,GAAG,EAAX;IACD;;IAED,OAAO,IAAIG,4BAAJ,CAAkC,IAAlC,EAAwCH,QAAxC,EAAkD,4BAAe,IAAf,EAAqBpG,OAArB,CAAlD,CAAP;EACD;;EAiCDwG,SAAS,CACPC,GADO,EAEPC,MAFO,EAGP1G,OAHO,EAIPyB,QAJO,EAImC;IAE1C,6BACE,0PADF;IAGA,IAAI,eAAe,OAAOzB,OAA1B,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC,CALO,CAM1C;IACA;;IACA,IAAI,QAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAE2G,GAAT,KAAgB,IAApB,EAA0B;MACxB,MAAM,IAAIpE,iCAAJ,CACJ,oEADI,CAAN;IAGD;;IAED,IAAI,eAAe,OAAOkE,GAA1B,EAA+B;MAC7BA,GAAG,GAAGA,GAAG,CAACtF,QAAJ,EAAN;IACD;;IAED,IAAI,eAAe,OAAOuF,MAA1B,EAAkC;MAChCA,MAAM,GAAGA,MAAM,CAACvF,QAAP,EAAT;IACD;;IAED,IAAI,eAAe,OAAOnB,OAAO,CAAC4G,QAAlC,EAA4C;MAC1C5G,OAAO,CAAC4G,QAAR,GAAmB5G,OAAO,CAAC4G,QAAR,CAAiBzF,QAAjB,EAAnB;IACD;;IAED,OAAO,0CACL,KAAKlB,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAIiF,+BAAJ,CACE,IADF,EAEEJ,GAFF,EAGEC,MAHF,EAIE,4BAAe,IAAf,EAAqB1G,OAArB,CAJF,CAFK,EAQLyB,QARK,CAAP;EAUD;EAED;;;;;;;;;;EAQAqF,yBAAyB,CAAC9G,OAAD,EAA2B;IAClD,OAAO,IAAI+G,kCAAJ,CAA2B,IAA3B,EAAmD,4BAAe,IAAf,EAAqB/G,OAArB,CAAnD,CAAP;EACD;EAED;;;;;;;;;;EAQAgH,uBAAuB,CAAChH,OAAD,EAA2B;IAChD,OAAO,IAAIiH,8BAAJ,CAAyB,IAAzB,EAAiD,4BAAe,IAAf,EAAqBjH,OAArB,CAAjD,CAAP;EACD;EAED;;;EACAkH,SAAS;IACP,OAAO,KAAKjH,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAYkH,MAAnB;EACD;;EAES,IAANA,MAAM;IACR,OAAO,KAAKlH,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAYkH,MAAnB;EACD;EAED;;;;;;;;;;;;EAUAC,MAAM,CACJrF,IADI,EAEJ/B,OAFI,EAGJyB,QAHI,EAGyC;IAE7C,6BACE,kFADF;IAGA,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAGA,OAAO,IAAI;MAAEkC,OAAO,EAAE;IAAX,CAArB;IACAH,IAAI,GAAG,CAACM,KAAK,CAACC,OAAN,CAAcP,IAAd,CAAD,GAAuB,CAACA,IAAD,CAAvB,GAAgCA,IAAvC;;IAEA,IAAI/B,OAAO,CAACqH,SAAR,KAAsB,IAA1B,EAAgC;MAC9BrH,OAAO,CAACkC,OAAR,GAAkB,KAAlB;IACD;;IAED,OAAO,KAAKJ,UAAL,CAAgBC,IAAhB,EAAsB/B,OAAtB,EAA+ByB,QAA/B,CAAP;EACD;EAED;;;;;;;;;;;EASAkB,MAAM,CACJD,MADI,EAEJC,MAFI,EAGJ3C,OAHI,EAIJyB,QAJI,EAIwB;IAE5B,6BACE,mFADF;IAGA,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAGA,OAAO,SAAP,WAAO,WAAP,aAAW,EAArB;IAEA,OAAO,KAAK+C,UAAL,CAAgBL,MAAhB,EAAwBC,MAAxB,EAAgC3C,OAAhC,EAAyCyB,QAAzC,CAAP;EACD;EAED;;;;;;;;;;EAQA6F,MAAM,CACJ5E,MADI,EAEJ1C,OAFI,EAGJyB,QAHI,EAGc;IAElB,6BACE,mFADF;IAGA,IAAI,OAAOzB,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAGA,OAAO,SAAP,WAAO,WAAP,aAAW,EAArB;IAEA,OAAO,KAAKkD,UAAL,CAAgBR,MAAhB,EAAwB1C,OAAxB,EAAiCyB,QAAjC,CAAP;EACD;;EA4BD8F,KAAK,CACH7E,MADG,EAEH1C,OAFG,EAGHyB,QAHG,EAGwB;IAE3B,IAAI,OAAOiB,MAAP,KAAkB,UAAtB,EAAkC;MAC/BjB,QAAQ,GAAGiB,MAAZ,EAAsBA,MAAM,GAAG,EAA/B,EAAqC1C,OAAO,GAAG,EAA/C;IACD,CAFD,MAEO;MACL,IAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAoCyB,QAAQ,GAAGzB,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACpC;;IAED0C,MAAM,SAAN,UAAM,WAAN,kBAAM,GAAK,EAAX;IACA,OAAO,0CACL,KAAKzC,CAAL,CAAOH,EAAP,CAAUG,CAAV,CAAY2B,MADP,EAEL,IAAI4F,sBAAJ,CACErH,yBAAiBsH,UAAjB,CAA4B,KAAKvH,SAAjC,CADF,EAEEwC,MAFF,EAGE,4BAAe,IAAf,EAAqB1C,OAArB,CAHF,CAFK,EAOLyB,QAPK,CAAP;EASD;;AAvjDoB;;AAAvBiG","names":["Collection","constructor","db","name","options","s","namespace","utils_1","databaseName","pkFactory","_a","_b","readPreference","read_preference_1","fromOptions","bsonOptions","readConcern","read_concern_1","writeConcern","write_concern_1","dbName","collectionName","collection","toString","hint","collectionHint","v","insertOne","doc","callback","Reflect","get","client","insert_1","insertMany","docs","Object","assign","ordered","bulkWrite","operations","Array","isArray","error_1","bulk_write_1","updateOne","filter","update","update_1","replaceOne","replacement","updateMany","deleteOne","delete_1","deleteMany","undefined","rename","newName","rename_1","PRIMARY","drop","drop_1","findOne","finalFilter","finalOptions","find","limit","batchSize","next","arguments","length","find_cursor_1","options_operation_1","isCapped","is_capped_1","createIndex","indexSpec","indexes_1","createIndexes","indexSpecs","maxTimeMS","dropIndex","indexName","primary","dropIndexes","listIndexes","list_indexes_cursor_1","indexExists","indexes","indexInformation","estimatedDocumentCount","estimated_document_count_1","countDocuments","count_documents_1","distinct","key","distinct_1","stats","stats_1","findOneAndDelete","find_and_modify_1","findOneAndReplace","findOneAndUpdate","aggregate","pipeline","aggregation_cursor_1","watch","change_stream_1","mapReduce","map","reduce","out","finalize","map_reduce_1","initializeUnorderedBulkOp","unordered_1","initializeOrderedBulkOp","ordered_1","getLogger","logger","insert","keepGoing","remove","count","count_1","fromString","exports"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\collection.ts"],"sourcesContent":["import { BSONSerializeOptions, Document, resolveBSONOptions } from './bson';\nimport type { AnyBulkWriteOperation, BulkWriteOptions, BulkWriteResult } from './bulk/common';\nimport { OrderedBulkOperation } from './bulk/ordered';\nimport { UnorderedBulkOperation } from './bulk/unordered';\nimport { ChangeStream, ChangeStreamDocument, ChangeStreamOptions } from './change_stream';\nimport { AggregationCursor } from './cursor/aggregation_cursor';\nimport { FindCursor } from './cursor/find_cursor';\nimport { ListIndexesCursor } from './cursor/list_indexes_cursor';\nimport type { Db } from './db';\nimport { MongoInvalidArgumentError } from './error';\nimport type { Logger, LoggerOptions } from './logger';\nimport type { PkFactory } from './mongo_client';\nimport type {\n  Filter,\n  Flatten,\n  OptionalUnlessRequiredId,\n  TODO_NODE_3286,\n  UpdateFilter,\n  WithId,\n  WithoutId\n} from './mongo_types';\nimport type { AggregateOptions } from './operations/aggregate';\nimport { BulkWriteOperation } from './operations/bulk_write';\nimport type { IndexInformationOptions } from './operations/common_functions';\nimport { CountOperation, CountOptions } from './operations/count';\nimport { CountDocumentsOperation, CountDocumentsOptions } from './operations/count_documents';\nimport {\n  DeleteManyOperation,\n  DeleteOneOperation,\n  DeleteOptions,\n  DeleteResult\n} from './operations/delete';\nimport { DistinctOperation, DistinctOptions } from './operations/distinct';\nimport { DropCollectionOperation, DropCollectionOptions } from './operations/drop';\nimport {\n  EstimatedDocumentCountOperation,\n  EstimatedDocumentCountOptions\n} from './operations/estimated_document_count';\nimport { executeOperation } from './operations/execute_operation';\nimport type { FindOptions } from './operations/find';\nimport {\n  FindOneAndDeleteOperation,\n  FindOneAndDeleteOptions,\n  FindOneAndReplaceOperation,\n  FindOneAndReplaceOptions,\n  FindOneAndUpdateOperation,\n  FindOneAndUpdateOptions\n} from './operations/find_and_modify';\nimport {\n  CreateIndexesOperation,\n  CreateIndexesOptions,\n  CreateIndexOperation,\n  DropIndexesOperation,\n  DropIndexesOptions,\n  DropIndexOperation,\n  IndexDescription,\n  IndexesOperation,\n  IndexExistsOperation,\n  IndexInformationOperation,\n  IndexSpecification,\n  ListIndexesOptions\n} from './operations/indexes';\nimport {\n  InsertManyOperation,\n  InsertManyResult,\n  InsertOneOperation,\n  InsertOneOptions,\n  InsertOneResult\n} from './operations/insert';\nimport { IsCappedOperation } from './operations/is_capped';\nimport {\n  MapFunction,\n  MapReduceOperation,\n  MapReduceOptions,\n  ReduceFunction\n} from './operations/map_reduce';\nimport type { Hint, OperationOptions } from './operations/operation';\nimport { OptionsOperation } from './operations/options_operation';\nimport { RenameOperation, RenameOptions } from './operations/rename';\nimport { CollStats, CollStatsOperation, CollStatsOptions } from './operations/stats';\nimport {\n  ReplaceOneOperation,\n  ReplaceOptions,\n  UpdateManyOperation,\n  UpdateOneOperation,\n  UpdateOptions,\n  UpdateResult\n} from './operations/update';\nimport { ReadConcern, ReadConcernLike } from './read_concern';\nimport { ReadPreference, ReadPreferenceLike } from './read_preference';\nimport {\n  Callback,\n  checkCollectionName,\n  DEFAULT_PK_FACTORY,\n  emitWarningOnce,\n  MongoDBNamespace,\n  normalizeHintField,\n  resolveOptions\n} from './utils';\nimport { WriteConcern, WriteConcernOptions } from './write_concern';\n\n/**\n * @public\n * @deprecated This type will be completely removed in 5.0 and findOneAndUpdate,\n *             findOneAndDelete, and findOneAndReplace will then return the\n *             actual result document.\n */\nexport interface ModifyResult<TSchema = Document> {\n  value: WithId<TSchema> | null;\n  lastErrorObject?: Document;\n  ok: 0 | 1;\n}\n\n/** @public */\nexport interface CollectionOptions\n  extends BSONSerializeOptions,\n    WriteConcernOptions,\n    LoggerOptions {\n  /**\n   * @deprecated Use readPreference instead\n   */\n  slaveOk?: boolean;\n  /** Specify a read concern for the collection. (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcernLike;\n  /** The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST). */\n  readPreference?: ReadPreferenceLike;\n}\n\n/** @internal */\nexport interface CollectionPrivate {\n  pkFactory: PkFactory;\n  db: Db;\n  options: any;\n  namespace: MongoDBNamespace;\n  readPreference?: ReadPreference;\n  bsonOptions: BSONSerializeOptions;\n  collectionHint?: Hint;\n  readConcern?: ReadConcern;\n  writeConcern?: WriteConcern;\n}\n\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * interface Pet {\n *   name: string;\n *   kind: 'dog' | 'cat' | 'fish';\n * }\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const pets = client.db().collection<Pet>('pets');\n *\n * const petCursor = pets.find();\n *\n * for await (const pet of petCursor) {\n *   console.log(`${pet.name} is a ${pet.kind}!`);\n * }\n * ```\n */\nexport class Collection<TSchema extends Document = Document> {\n  /** @internal */\n  s: CollectionPrivate;\n\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db: Db, name: string, options?: CollectionOptions) {\n    checkCollectionName(name);\n\n    // Internal state\n    this.s = {\n      db,\n      options,\n      namespace: new MongoDBNamespace(db.databaseName, name),\n      pkFactory: db.options?.pkFactory ?? DEFAULT_PK_FACTORY,\n      readPreference: ReadPreference.fromOptions(options),\n      bsonOptions: resolveBSONOptions(options, db),\n      readConcern: ReadConcern.fromOptions(options),\n      writeConcern: WriteConcern.fromOptions(options)\n    };\n  }\n\n  /**\n   * The name of the database this collection belongs to\n   */\n  get dbName(): string {\n    return this.s.namespace.db;\n  }\n\n  /**\n   * The name of this collection\n   */\n  get collectionName(): string {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.s.namespace.collection!;\n  }\n\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n  get namespace(): string {\n    return this.s.namespace.toString();\n  }\n\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readConcern(): ReadConcern | undefined {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n    return this.s.readConcern;\n  }\n\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readPreference(): ReadPreference | undefined {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n\n  get bsonOptions(): BSONSerializeOptions {\n    return this.s.bsonOptions;\n  }\n\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get writeConcern(): WriteConcern | undefined {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n    return this.s.writeConcern;\n  }\n\n  /** The current index hint for the collection */\n  get hint(): Hint | undefined {\n    return this.s.collectionHint;\n  }\n\n  set hint(v: Hint | undefined) {\n    this.s.collectionHint = normalizeHintField(v);\n  }\n\n  /**\n   * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param doc - The document to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  insertOne(doc: OptionalUnlessRequiredId<TSchema>): Promise<InsertOneResult<TSchema>>;\n  insertOne(\n    doc: OptionalUnlessRequiredId<TSchema>,\n    options: InsertOneOptions\n  ): Promise<InsertOneResult<TSchema>>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  insertOne(\n    doc: OptionalUnlessRequiredId<TSchema>,\n    callback: Callback<InsertOneResult<TSchema>>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  insertOne(\n    doc: OptionalUnlessRequiredId<TSchema>,\n    options: InsertOneOptions,\n    callback: Callback<InsertOneResult<TSchema>>\n  ): void;\n  insertOne(\n    doc: OptionalUnlessRequiredId<TSchema>,\n    options?: InsertOneOptions | Callback<InsertOneResult<TSchema>>,\n    callback?: Callback<InsertOneResult<TSchema>>\n  ): Promise<InsertOneResult<TSchema>> | void {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    // versions of mongodb-client-encryption before v1.2.6 pass in hardcoded { w: 'majority' }\n    // specifically to an insertOne call in createDataKey, so we want to support this only here\n    if (options && Reflect.get(options, 'w')) {\n      options.writeConcern = WriteConcern.fromOptions(Reflect.get(options, 'w'));\n    }\n\n    return executeOperation(\n      this.s.db.s.client,\n      new InsertOneOperation(\n        this as TODO_NODE_3286,\n        doc,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  insertMany(docs: OptionalUnlessRequiredId<TSchema>[]): Promise<InsertManyResult<TSchema>>;\n  insertMany(\n    docs: OptionalUnlessRequiredId<TSchema>[],\n    options: BulkWriteOptions\n  ): Promise<InsertManyResult<TSchema>>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  insertMany(\n    docs: OptionalUnlessRequiredId<TSchema>[],\n    callback: Callback<InsertManyResult<TSchema>>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  insertMany(\n    docs: OptionalUnlessRequiredId<TSchema>[],\n    options: BulkWriteOptions,\n    callback: Callback<InsertManyResult<TSchema>>\n  ): void;\n  insertMany(\n    docs: OptionalUnlessRequiredId<TSchema>[],\n    options?: BulkWriteOptions | Callback<InsertManyResult<TSchema>>,\n    callback?: Callback<InsertManyResult<TSchema>>\n  ): Promise<InsertManyResult<TSchema>> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ? Object.assign({}, options) : { ordered: true };\n\n    return executeOperation(\n      this.s.db.s.client,\n      new InsertManyOperation(\n        this as TODO_NODE_3286,\n        docs,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Perform a bulkWrite operation without a fluent API\n   *\n   * Legal operation types are\n   * - `insertOne`\n   * - `replaceOne`\n   * - `updateOne`\n   * - `updateMany`\n   * - `deleteOne`\n   * - `deleteMany`\n   *\n   * Please note that raw operations are no longer accepted as of driver version 4.0.\n   *\n   * If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param operations - Bulk operations to perform\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   * @throws MongoDriverError if operations is not an array\n   */\n  bulkWrite(operations: AnyBulkWriteOperation<TSchema>[]): Promise<BulkWriteResult>;\n  bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    options: BulkWriteOptions\n  ): Promise<BulkWriteResult>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    callback: Callback<BulkWriteResult>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    options: BulkWriteOptions,\n    callback: Callback<BulkWriteResult>\n  ): void;\n  bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    options?: BulkWriteOptions | Callback<BulkWriteResult>,\n    callback?: Callback<BulkWriteResult>\n  ): Promise<BulkWriteResult> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options || { ordered: true };\n\n    if (!Array.isArray(operations)) {\n      throw new MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n    }\n\n    return executeOperation(\n      this.s.db.s.client,\n      new BulkWriteOperation(\n        this as TODO_NODE_3286,\n        operations as TODO_NODE_3286,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Update a single document in a collection\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - The update operations to be applied to the document\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>\n  ): Promise<UpdateResult>;\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    options: UpdateOptions\n  ): Promise<UpdateResult>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    callback: Callback<UpdateResult>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    options: UpdateOptions,\n    callback: Callback<UpdateResult>\n  ): void;\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    options?: UpdateOptions | Callback<UpdateResult>,\n    callback?: Callback<UpdateResult>\n  ): Promise<UpdateResult> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new UpdateOneOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Replace a document in a collection with another document\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  replaceOne(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>\n  ): Promise<UpdateResult | Document>;\n  replaceOne(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options: ReplaceOptions\n  ): Promise<UpdateResult | Document>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  replaceOne(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  replaceOne(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options: ReplaceOptions,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  replaceOne(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options?: ReplaceOptions | Callback<UpdateResult | Document>,\n    callback?: Callback<UpdateResult | Document>\n  ): Promise<UpdateResult | Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new ReplaceOneOperation(\n        this as TODO_NODE_3286,\n        filter,\n        replacement,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Update multiple documents in a collection\n   *\n   * @param filter - The filter used to select the documents to update\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>\n  ): Promise<UpdateResult | Document>;\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: UpdateOptions\n  ): Promise<UpdateResult | Document>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: UpdateOptions,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: UpdateOptions | Callback<UpdateResult | Document>,\n    callback?: Callback<UpdateResult | Document>\n  ): Promise<UpdateResult | Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new UpdateManyOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Delete a document from a collection\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  deleteOne(filter: Filter<TSchema>): Promise<DeleteResult>;\n  deleteOne(filter: Filter<TSchema>, options: DeleteOptions): Promise<DeleteResult>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  deleteOne(filter: Filter<TSchema>, callback: Callback<DeleteResult>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  deleteOne(\n    filter: Filter<TSchema>,\n    options: DeleteOptions,\n    callback?: Callback<DeleteResult>\n  ): void;\n  deleteOne(\n    filter: Filter<TSchema>,\n    options?: DeleteOptions | Callback<DeleteResult>,\n    callback?: Callback<DeleteResult>\n  ): Promise<DeleteResult> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new DeleteOneOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Delete multiple documents from a collection\n   *\n   * @param filter - The filter used to select the documents to remove\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  deleteMany(filter: Filter<TSchema>): Promise<DeleteResult>;\n  deleteMany(filter: Filter<TSchema>, options: DeleteOptions): Promise<DeleteResult>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  deleteMany(filter: Filter<TSchema>, callback: Callback<DeleteResult>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  deleteMany(\n    filter: Filter<TSchema>,\n    options: DeleteOptions,\n    callback: Callback<DeleteResult>\n  ): void;\n  deleteMany(\n    filter: Filter<TSchema>,\n    options?: DeleteOptions | Callback<DeleteResult>,\n    callback?: Callback<DeleteResult>\n  ): Promise<DeleteResult> | void {\n    if (filter == null) {\n      filter = {};\n      options = {};\n      callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter as Callback<DeleteResult>;\n      filter = {};\n      options = {};\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return executeOperation(\n      this.s.db.s.client,\n      new DeleteManyOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Rename the collection.\n   *\n   * @remarks\n   * This operation does not inherit options from the Db or MongoClient.\n   *\n   * @param newName - New name of of the collection.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  rename(newName: string): Promise<Collection>;\n  rename(newName: string, options: RenameOptions): Promise<Collection>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  rename(newName: string, callback: Callback<Collection>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  rename(newName: string, options: RenameOptions, callback: Callback<Collection>): void;\n  rename(\n    newName: string,\n    options?: RenameOptions | Callback<Collection>,\n    callback?: Callback<Collection>\n  ): Promise<Collection> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    // Intentionally, we do not inherit options from parent for this operation.\n    return executeOperation(\n      this.s.db.s.client,\n      new RenameOperation(this as TODO_NODE_3286, newName, {\n        ...options,\n        readPreference: ReadPreference.PRIMARY\n      }) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  drop(): Promise<boolean>;\n  drop(options: DropCollectionOptions): Promise<boolean>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  drop(callback: Callback<boolean>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  drop(options: DropCollectionOptions, callback: Callback<boolean>): void;\n  drop(\n    options?: DropCollectionOptions | Callback<boolean>,\n    callback?: Callback<boolean>\n  ): Promise<boolean> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    return executeOperation(\n      this.s.db.s.client,\n      new DropCollectionOperation(this.s.db, this.collectionName, options),\n      callback\n    );\n  }\n\n  /**\n   * Fetches the first document that matches the filter\n   *\n   * @param filter - Query for find Operation\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  findOne(): Promise<WithId<TSchema> | null>;\n  findOne(filter: Filter<TSchema>): Promise<WithId<TSchema> | null>;\n  findOne(filter: Filter<TSchema>, options: FindOptions): Promise<WithId<TSchema> | null>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOne(callback: Callback<WithId<TSchema> | null>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOne(filter: Filter<TSchema>, callback: Callback<WithId<TSchema> | null>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOne(\n    filter: Filter<TSchema>,\n    options: FindOptions,\n    callback: Callback<WithId<TSchema> | null>\n  ): void;\n\n  // allow an override of the schema.\n  findOne<T = TSchema>(): Promise<T | null>;\n  findOne<T = TSchema>(filter: Filter<TSchema>): Promise<T | null>;\n  findOne<T = TSchema>(filter: Filter<TSchema>, options?: FindOptions): Promise<T | null>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOne<T = TSchema>(callback: Callback<T | null>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOne<T = TSchema>(\n    filter: Filter<TSchema>,\n    options?: FindOptions,\n    callback?: Callback<T | null>\n  ): void;\n\n  findOne(\n    filter?: Filter<TSchema> | Callback<WithId<TSchema> | null>,\n    options?: FindOptions | Callback<WithId<TSchema> | null>,\n    callback?: Callback<WithId<TSchema> | null>\n  ): Promise<WithId<TSchema> | null> | void {\n    if (callback != null && typeof callback !== 'function') {\n      throw new MongoInvalidArgumentError(\n        'Third parameter to `findOne()` must be a callback or undefined'\n      );\n    }\n\n    if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    }\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    const finalFilter = filter ?? {};\n    const finalOptions = options ?? {};\n    return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);\n  }\n\n  /**\n   * Creates a cursor for a filter that can be used to iterate over results from MongoDB\n   *\n   * @param filter - The filter predicate. If unspecified, then all documents in the collection will match the predicate\n   */\n  find(): FindCursor<WithId<TSchema>>;\n  find(filter: Filter<TSchema>, options?: FindOptions): FindCursor<WithId<TSchema>>;\n  find<T extends Document>(filter: Filter<TSchema>, options?: FindOptions): FindCursor<T>;\n  find(filter?: Filter<TSchema>, options?: FindOptions): FindCursor<WithId<TSchema>> {\n    if (arguments.length > 2) {\n      throw new MongoInvalidArgumentError(\n        'Method \"collection.find()\" accepts at most two arguments'\n      );\n    }\n    if (typeof options === 'function') {\n      throw new MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new FindCursor<WithId<TSchema>>(\n      this.s.db.s.client,\n      this.s.namespace,\n      filter,\n      resolveOptions(this as TODO_NODE_3286, options)\n    );\n  }\n\n  /**\n   * Returns the options of the collection.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  options(): Promise<Document>;\n  options(options: OperationOptions): Promise<Document>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  options(callback: Callback<Document>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  options(options: OperationOptions, callback: Callback<Document>): void;\n  options(\n    options?: OperationOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new OptionsOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Returns if the collection is a capped collection\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  isCapped(): Promise<boolean>;\n  isCapped(options: OperationOptions): Promise<boolean>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  isCapped(callback: Callback<boolean>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  isCapped(options: OperationOptions, callback: Callback<boolean>): void;\n  isCapped(\n    options?: OperationOptions | Callback<boolean>,\n    callback?: Callback<boolean>\n  ): Promise<boolean> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new IsCappedOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Creates an index on the db and collection collection.\n   *\n   * @param indexSpec - The field name or index specification to create an index for\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   *\n   * await collection.createIndex({ a: 1, b: -1 });\n   *\n   * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n   * await collection.createIndex([ [c, 1], [d, -1] ]);\n   *\n   * // Equivalent to { e: 1 }\n   * await collection.createIndex('e');\n   *\n   * // Equivalent to { f: 1, g: 1 }\n   * await collection.createIndex(['f', 'g'])\n   *\n   * // Equivalent to { h: 1, i: -1 }\n   * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n   *\n   * // Equivalent to { j: 1, k: -1, l: 2d }\n   * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n   * ```\n   */\n  createIndex(indexSpec: IndexSpecification): Promise<string>;\n  createIndex(indexSpec: IndexSpecification, options: CreateIndexesOptions): Promise<string>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  createIndex(indexSpec: IndexSpecification, callback: Callback<string>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  createIndex(\n    indexSpec: IndexSpecification,\n    options: CreateIndexesOptions,\n    callback: Callback<string>\n  ): void;\n  createIndex(\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions | Callback<string>,\n    callback?: Callback<string>\n  ): Promise<string> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new CreateIndexOperation(\n        this as TODO_NODE_3286,\n        this.collectionName,\n        indexSpec,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Creates multiple indexes in the collection, this method is only supported for\n   * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n   * error.\n   *\n   * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\n   * Index specifications are defined {@link http://docs.mongodb.org/manual/reference/command/createIndexes/| here}.\n   *\n   * @param indexSpecs - An array of index specifications to be created\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   * await collection.createIndexes([\n   *   // Simple index on field fizz\n   *   {\n   *     key: { fizz: 1 },\n   *   }\n   *   // wildcard index\n   *   {\n   *     key: { '$**': 1 }\n   *   },\n   *   // named index on darmok and jalad\n   *   {\n   *     key: { darmok: 1, jalad: -1 }\n   *     name: 'tanagra'\n   *   }\n   * ]);\n   * ```\n   */\n  createIndexes(indexSpecs: IndexDescription[]): Promise<string[]>;\n  createIndexes(indexSpecs: IndexDescription[], options: CreateIndexesOptions): Promise<string[]>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  createIndexes(indexSpecs: IndexDescription[], callback: Callback<string[]>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  createIndexes(\n    indexSpecs: IndexDescription[],\n    options: CreateIndexesOptions,\n    callback: Callback<string[]>\n  ): void;\n  createIndexes(\n    indexSpecs: IndexDescription[],\n    options?: CreateIndexesOptions | Callback<string[]>,\n    callback?: Callback<string[]>\n  ): Promise<string[]> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ? Object.assign({}, options) : {};\n    if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n\n    return executeOperation(\n      this.s.db.s.client,\n      new CreateIndexesOperation(\n        this as TODO_NODE_3286,\n        this.collectionName,\n        indexSpecs,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Drops an index from this collection.\n   *\n   * @param indexName - Name of the index to drop.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  dropIndex(indexName: string): Promise<Document>;\n  dropIndex(indexName: string, options: DropIndexesOptions): Promise<Document>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  dropIndex(indexName: string, callback: Callback<Document>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  dropIndex(indexName: string, options: DropIndexesOptions, callback: Callback<Document>): void;\n  dropIndex(\n    indexName: string,\n    options?: DropIndexesOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = resolveOptions(this, options);\n\n    // Run only against primary\n    options.readPreference = ReadPreference.primary;\n\n    return executeOperation(\n      this.s.db.s.client,\n      new DropIndexOperation(this as TODO_NODE_3286, indexName, options),\n      callback\n    );\n  }\n\n  /**\n   * Drops all indexes from this collection.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  dropIndexes(): Promise<Document>;\n  dropIndexes(options: DropIndexesOptions): Promise<Document>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  dropIndexes(callback: Callback<Document>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  dropIndexes(options: DropIndexesOptions, callback: Callback<Document>): void;\n  dropIndexes(\n    options?: DropIndexesOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new DropIndexesOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  listIndexes(options?: ListIndexesOptions): ListIndexesCursor {\n    return new ListIndexesCursor(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /**\n   * Checks if one or more indexes exist on the collection, fails on first non-existing index\n   *\n   * @param indexes - One or more index names to check.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  indexExists(indexes: string | string[]): Promise<boolean>;\n  indexExists(indexes: string | string[], options: IndexInformationOptions): Promise<boolean>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  indexExists(indexes: string | string[], callback: Callback<boolean>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  indexExists(\n    indexes: string | string[],\n    options: IndexInformationOptions,\n    callback: Callback<boolean>\n  ): void;\n  indexExists(\n    indexes: string | string[],\n    options?: IndexInformationOptions | Callback<boolean>,\n    callback?: Callback<boolean>\n  ): Promise<boolean> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new IndexExistsOperation(this as TODO_NODE_3286, indexes, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Retrieves this collections index info.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  indexInformation(): Promise<Document>;\n  indexInformation(options: IndexInformationOptions): Promise<Document>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  indexInformation(callback: Callback<Document>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  indexInformation(options: IndexInformationOptions, callback: Callback<Document>): void;\n  indexInformation(\n    options?: IndexInformationOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new IndexInformationOperation(this.s.db, this.collectionName, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Gets an estimate of the count of documents in a collection using collection metadata.\n   * This will always run a count command on all server versions.\n   *\n   * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,\n   * which estimatedDocumentCount uses in its implementation, was not included in v1 of\n   * the Stable API, and so users of the Stable API with estimatedDocumentCount are\n   * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid\n   * encountering errors.\n   *\n   * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  estimatedDocumentCount(): Promise<number>;\n  estimatedDocumentCount(options: EstimatedDocumentCountOptions): Promise<number>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  estimatedDocumentCount(callback: Callback<number>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  estimatedDocumentCount(options: EstimatedDocumentCountOptions, callback: Callback<number>): void;\n  estimatedDocumentCount(\n    options?: EstimatedDocumentCountOptions | Callback<number>,\n    callback?: Callback<number>\n  ): Promise<number> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    return executeOperation(\n      this.s.db.s.client,\n      new EstimatedDocumentCountOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Gets the number of documents matching the filter.\n   * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\n   * the following query operators must be replaced:\n   *\n   * | Operator | Replacement |\n   * | -------- | ----------- |\n   * | `$where`   | [`$expr`][1] |\n   * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n   * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n   *\n   * [1]: https://docs.mongodb.com/manual/reference/operator/query/expr/\n   * [2]: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n   * [3]: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n   * [4]: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   *\n   * @param filter - The filter for the count\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   *\n   * @see https://docs.mongodb.com/manual/reference/operator/query/expr/\n   * @see https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n   * @see https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n   * @see https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   */\n  countDocuments(): Promise<number>;\n  countDocuments(filter: Filter<TSchema>): Promise<number>;\n  countDocuments(filter: Filter<TSchema>, options: CountDocumentsOptions): Promise<number>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  countDocuments(callback: Callback<number>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  countDocuments(filter: Filter<TSchema>, callback: Callback<number>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  countDocuments(\n    filter: Filter<TSchema>,\n    options: CountDocumentsOptions,\n    callback: Callback<number>\n  ): void;\n  countDocuments(\n    filter?: Document | CountDocumentsOptions | Callback<number>,\n    options?: CountDocumentsOptions | Callback<number>,\n    callback?: Callback<number>\n  ): Promise<number> | void {\n    if (filter == null) {\n      (filter = {}), (options = {}), (callback = undefined);\n    } else if (typeof filter === 'function') {\n      (callback = filter as Callback<number>), (filter = {}), (options = {});\n    } else {\n      if (arguments.length === 2) {\n        if (typeof options === 'function') (callback = options), (options = {});\n      }\n    }\n\n    filter ??= {};\n    return executeOperation(\n      this.s.db.s.client,\n      new CountDocumentsOperation(\n        this as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options as CountDocumentsOptions)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * The distinct command returns a list of distinct values for the given key across a collection.\n   *\n   * @param key - Field of the document to find distinct values for\n   * @param filter - The filter for filtering the set of documents to which we apply the distinct filter.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>,\n    options: DistinctOptions\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    callback: Callback<Array<Flatten<WithId<TSchema>[Key]>>>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>,\n    callback: Callback<Array<Flatten<WithId<TSchema>[Key]>>>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>,\n    options: DistinctOptions,\n    callback: Callback<Array<Flatten<WithId<TSchema>[Key]>>>\n  ): void;\n\n  // Embedded documents overload\n  distinct(key: string): Promise<any[]>;\n  distinct(key: string, filter: Filter<TSchema>): Promise<any[]>;\n  distinct(key: string, filter: Filter<TSchema>, options: DistinctOptions): Promise<any[]>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  distinct(key: string, callback: Callback<any[]>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  distinct(key: string, filter: Filter<TSchema>, callback: Callback<any[]>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  distinct(\n    key: string,\n    filter: Filter<TSchema>,\n    options: DistinctOptions,\n    callback: Callback<any[]>\n  ): void;\n  // Implementation\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter?: Filter<TSchema> | DistinctOptions | Callback<any[]>,\n    options?: DistinctOptions | Callback<any[]>,\n    callback?: Callback<any[]>\n  ): Promise<any[]> | void {\n    if (typeof filter === 'function') {\n      (callback = filter), (filter = {}), (options = {});\n    } else {\n      if (arguments.length === 3 && typeof options === 'function') {\n        (callback = options), (options = {});\n      }\n    }\n\n    filter ??= {};\n    return executeOperation(\n      this.s.db.s.client,\n      new DistinctOperation(\n        this as TODO_NODE_3286,\n        key as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options as DistinctOptions)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Retrieve all the indexes on the collection.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  indexes(): Promise<Document[]>;\n  indexes(options: IndexInformationOptions): Promise<Document[]>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  indexes(callback: Callback<Document[]>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  indexes(options: IndexInformationOptions, callback: Callback<Document[]>): void;\n  indexes(\n    options?: IndexInformationOptions | Callback<Document[]>,\n    callback?: Callback<Document[]>\n  ): Promise<Document[]> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new IndexesOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Get all the collection statistics.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  stats(): Promise<CollStats>;\n  stats(options: CollStatsOptions): Promise<CollStats>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  stats(callback: Callback<CollStats>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  stats(options: CollStatsOptions, callback: Callback<CollStats>): void;\n  stats(\n    options?: CollStatsOptions | Callback<CollStats>,\n    callback?: Callback<CollStats>\n  ): Promise<CollStats> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    return executeOperation(\n      this.s.db.s.client,\n      new CollStatsOperation(this as TODO_NODE_3286, options) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  findOneAndDelete(filter: Filter<TSchema>): Promise<ModifyResult<TSchema>>;\n  findOneAndDelete(\n    filter: Filter<TSchema>,\n    options: FindOneAndDeleteOptions\n  ): Promise<ModifyResult<TSchema>>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOneAndDelete(filter: Filter<TSchema>, callback: Callback<ModifyResult<TSchema>>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOneAndDelete(\n    filter: Filter<TSchema>,\n    options: FindOneAndDeleteOptions,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  findOneAndDelete(\n    filter: Filter<TSchema>,\n    options?: FindOneAndDeleteOptions | Callback<ModifyResult<TSchema>>,\n    callback?: Callback<ModifyResult<TSchema>>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new FindOneAndDeleteOperation(\n        this as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>\n  ): Promise<ModifyResult<TSchema>>;\n  findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options: FindOneAndReplaceOptions\n  ): Promise<ModifyResult<TSchema>>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options: FindOneAndReplaceOptions,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options?: FindOneAndReplaceOptions | Callback<ModifyResult<TSchema>>,\n    callback?: Callback<ModifyResult<TSchema>>\n  ): Promise<ModifyResult<TSchema>> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new FindOneAndReplaceOperation(\n        this as TODO_NODE_3286,\n        filter,\n        replacement,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - Update operations to be performed on the document\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>\n  ): Promise<ModifyResult<TSchema>>;\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: FindOneAndUpdateOptions\n  ): Promise<ModifyResult<TSchema>>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: FindOneAndUpdateOptions,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: FindOneAndUpdateOptions | Callback<ModifyResult<TSchema>>,\n    callback?: Callback<ModifyResult<TSchema>>\n  ): Promise<ModifyResult<TSchema>> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      this.s.db.s.client,\n      new FindOneAndUpdateOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n  aggregate<T extends Document = Document>(\n    pipeline: Document[] = [],\n    options?: AggregateOptions\n  ): AggregationCursor<T> {\n    if (arguments.length > 2) {\n      throw new MongoInvalidArgumentError(\n        'Method \"collection.aggregate()\" accepts at most two arguments'\n      );\n    }\n    if (!Array.isArray(pipeline)) {\n      throw new MongoInvalidArgumentError(\n        'Argument \"pipeline\" must be an array of aggregation stages'\n      );\n    }\n    if (typeof options === 'function') {\n      throw new MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new AggregationCursor(\n      this.s.db.s.client,\n      this.s.namespace,\n      pipeline,\n      resolveOptions(this, options)\n    );\n  }\n\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to override the schema that may be defined for this specific collection\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   * @example\n   * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n   * ```ts\n   * collection.watch<{ _id: number }>()\n   *   .on('change', change => console.log(change._id.toFixed(4)));\n   * ```\n   *\n   * @example\n   * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n   * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n   * No need start from scratch on the ChangeStreamInsertDocument type!\n   * By using an intersection we can save time and ensure defaults remain the same type!\n   * ```ts\n   * collection\n   *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n   *     { $addFields: { comment: 'big changes' } },\n   *     { $match: { operationType: 'insert' } }\n   *   ])\n   *   .on('change', change => {\n   *     change.comment.startsWith('big');\n   *     change.operationType === 'insert';\n   *     // No need to narrow in code because the generics did that for us!\n   *     expectType<Schema>(change.fullDocument);\n   *   });\n   * ```\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TLocal - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n  watch<TLocal extends Document = TSchema, TChange extends Document = ChangeStreamDocument<TLocal>>(\n    pipeline: Document[] = [],\n    options: ChangeStreamOptions = {}\n  ): ChangeStream<TLocal, TChange> {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new ChangeStream<TLocal, TChange>(this, pipeline, resolveOptions(this, options));\n  }\n\n  /**\n   * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n   *\n   * @deprecated collection.mapReduce is deprecated. Use the aggregation pipeline instead. Visit https://docs.mongodb.com/manual/reference/map-reduce-to-aggregation-pipeline for more information on how to translate map-reduce operations to the aggregation pipeline.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>\n  ): Promise<Document | Document[]>;\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>,\n    options: MapReduceOptions<TKey, TValue>\n  ): Promise<Document | Document[]>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>,\n    callback: Callback<Document | Document[]>\n  ): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>,\n    options: MapReduceOptions<TKey, TValue>,\n    callback: Callback<Document | Document[]>\n  ): void;\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>,\n    options?: MapReduceOptions<TKey, TValue> | Callback<Document | Document[]>,\n    callback?: Callback<Document | Document[]>\n  ): Promise<Document | Document[]> | void {\n    emitWarningOnce(\n      'collection.mapReduce is deprecated. Use the aggregation pipeline instead. Visit https://docs.mongodb.com/manual/reference/map-reduce-to-aggregation-pipeline for more information on how to translate map-reduce operations to the aggregation pipeline.'\n    );\n    if ('function' === typeof options) (callback = options), (options = {});\n    // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n    // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n    if (options?.out == null) {\n      throw new MongoInvalidArgumentError(\n        'Option \"out\" must be defined, see mongodb docs for possible values'\n      );\n    }\n\n    if ('function' === typeof map) {\n      map = map.toString();\n    }\n\n    if ('function' === typeof reduce) {\n      reduce = reduce.toString();\n    }\n\n    if ('function' === typeof options.finalize) {\n      options.finalize = options.finalize.toString();\n    }\n\n    return executeOperation(\n      this.s.db.s.client,\n      new MapReduceOperation(\n        this as TODO_NODE_3286,\n        map,\n        reduce,\n        resolveOptions(this, options) as TODO_NODE_3286\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeUnorderedBulkOp(options?: BulkWriteOptions): UnorderedBulkOperation {\n    return new UnorderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /**\n   * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeOrderedBulkOp(options?: BulkWriteOptions): OrderedBulkOperation {\n    return new OrderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /** Get the db scoped logger */\n  getLogger(): Logger {\n    return this.s.db.s.logger;\n  }\n\n  get logger(): Logger {\n    return this.s.db.s.logger;\n  }\n\n  /**\n   * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @deprecated Use insertOne, insertMany or bulkWrite instead. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  insert(\n    docs: OptionalUnlessRequiredId<TSchema>[],\n    options: BulkWriteOptions,\n    callback: Callback<InsertManyResult<TSchema>>\n  ): Promise<InsertManyResult<TSchema>> | void {\n    emitWarningOnce(\n      'collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.'\n    );\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options || { ordered: false };\n    docs = !Array.isArray(docs) ? [docs] : docs;\n\n    if (options.keepGoing === true) {\n      options.ordered = false;\n    }\n\n    return this.insertMany(docs, options, callback);\n  }\n\n  /**\n   * Updates documents.\n   *\n   * @deprecated use updateOne, updateMany or bulkWrite. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance\n   * @param filter - The filter for the update operation.\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  update(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: UpdateOptions,\n    callback: Callback<Document>\n  ): Promise<UpdateResult> | void {\n    emitWarningOnce(\n      'collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.'\n    );\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    return this.updateMany(filter, update, options, callback);\n  }\n\n  /**\n   * Remove documents.\n   *\n   * @deprecated use deleteOne, deleteMany or bulkWrite. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance\n   * @param filter - The filter for the remove operation.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  remove(\n    filter: Filter<TSchema>,\n    options: DeleteOptions,\n    callback: Callback\n  ): Promise<DeleteResult> | void {\n    emitWarningOnce(\n      'collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.'\n    );\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    return this.deleteMany(filter, options, callback);\n  }\n\n  /**\n   * An estimated count of matching documents in the db to a filter.\n   *\n   * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n   * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\n   * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   *\n   * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\n   *\n   * @param filter - The filter for the count.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  count(): Promise<number>;\n  count(filter: Filter<TSchema>): Promise<number>;\n  count(filter: Filter<TSchema>, options: CountOptions): Promise<number>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  count(callback: Callback<number>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  count(filter: Filter<TSchema>, callback: Callback<number>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  count(\n    filter: Filter<TSchema>,\n    options: CountOptions,\n    callback: Callback<number>\n  ): Promise<number> | void;\n  count(\n    filter?: Filter<TSchema> | CountOptions | Callback<number>,\n    options?: CountOptions | Callback<number>,\n    callback?: Callback<number>\n  ): Promise<number> | void {\n    if (typeof filter === 'function') {\n      (callback = filter), (filter = {}), (options = {});\n    } else {\n      if (typeof options === 'function') (callback = options), (options = {});\n    }\n\n    filter ??= {};\n    return executeOperation(\n      this.s.db.s.client,\n      new CountOperation(\n        MongoDBNamespace.fromString(this.namespace),\n        filter,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}