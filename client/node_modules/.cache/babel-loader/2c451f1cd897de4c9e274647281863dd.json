{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MapReduceOperation = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n\nconst exclusionList = ['explain', 'readPreference', 'readConcern', 'session', 'bypassDocumentValidation', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation', 'scope' // this option is reformatted thus exclude the original\n];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\n\nclass MapReduceOperation extends command_1.CommandOperation {\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param collection - Collection instance.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  constructor(collection, map, reduce, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n    const mapCommandHash = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    };\n\n    if (options.scope) {\n      mapCommandHash.scope = processScope(options.scope);\n    } // Add any other options passed in\n\n\n    for (const n in options) {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) === -1) {\n        mapCommandHash[n] = options[n];\n      }\n    }\n\n    options = Object.assign({}, options); // If we have a read preference and inline is not set as output fail hard\n\n    if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== 'inline') {\n      // Force readPreference to primary\n      options.readPreference = read_preference_1.ReadPreference.primary; // Decorate command with writeConcern if supported\n\n      (0, utils_1.applyWriteConcern)(mapCommandHash, {\n        db: coll.s.db,\n        collection: coll\n      }, options);\n    } else {\n      (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);\n    } // Is bypassDocumentValidation specified\n\n\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    } // Have we specified collation\n\n\n    try {\n      (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err);\n    }\n\n    if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {\n      callback(new error_1.MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`));\n      return;\n    } // Execute command\n\n\n    super.executeCommand(server, session, mapCommandHash, (err, result) => {\n      if (err) return callback(err); // Check if we have an error\n\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return callback(new error_1.MongoServerError(result));\n      } // If an explain option was executed, don't process the server results\n\n\n      if (this.explain) return callback(undefined, result); // Create statistics value\n\n      const stats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing; // invoked with inline?\n\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(undefined, result.results);\n        }\n\n        return callback(undefined, {\n          results: result.results,\n          stats: stats\n        });\n      } // The returned collection\n\n\n      let collection = null; // If we have an object it's a different db\n\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result; // Return a collection from another db\n\n        collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      } // If we wish for no verbosity\n\n\n      if (options['verbose'] == null || !options['verbose']) {\n        return callback(err, collection);\n      } // Return stats as third set of values\n\n\n      callback(err, {\n        collection,\n        stats\n      });\n    });\n  }\n\n}\n\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\n\nfunction processScope(scope) {\n  if (!(0, utils_1.isObject)(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n\n  const newScope = {};\n\n  for (const key of Object.keys(scope)) {\n    if ('function' === typeof scope[key]) {\n      newScope[key] = new bson_1.Code(String(scope[key]));\n    } else if (scope[key]._bsontype === 'Code') {\n      newScope[key] = scope[key];\n    } else {\n      newScope[key] = processScope(scope[key]);\n    }\n  }\n\n  return newScope;\n}\n\n(0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);","map":{"version":3,"mappings":"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","names":["exclusionList","MapReduceOperation","command_1","constructor","collection","map","reduce","options","execute","server","session","callback","coll","mapCommandHash","mapReduce","collectionName","scope","processScope","n","indexOf","Object","assign","readPreference","mode","read_preference_1","primary","out","inline","db","s","bypassDocumentValidation","err","explain","error_1","name","executeCommand","result","ok","errmsg","undefined","stats","timeMillis","counts","timing","results","doc","client","exports","_bsontype","newScope","key","keys","bson_1","String","operation_1","EXPLAINABLE"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\operations\\map_reduce.ts"],"sourcesContent":["import type { ObjectId } from '../bson';\nimport { Code, Document } from '../bson';\nimport type { Collection } from '../collection';\nimport { MongoCompatibilityError, MongoServerError } from '../error';\nimport { ReadPreference, ReadPreferenceMode } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Sort } from '../sort';\nimport {\n  applyWriteConcern,\n  Callback,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  isObject,\n  maxWireVersion\n} from '../utils';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\nconst exclusionList = [\n  'explain',\n  'readPreference',\n  'readConcern',\n  'session',\n  'bypassDocumentValidation',\n  'writeConcern',\n  'raw',\n  'fieldsAsRaw',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'bsonRegExp',\n  'serializeFunctions',\n  'ignoreUndefined',\n  'enableUtf8Validation',\n  'scope' // this option is reformatted thus exclude the original\n];\n\n/** @public */\nexport type MapFunction<TSchema = Document> = (this: TSchema) => void;\n/** @public */\nexport type ReduceFunction<TKey = ObjectId, TValue = any> = (key: TKey, values: TValue[]) => TValue;\n/** @public */\nexport type FinalizeFunction<TKey = ObjectId, TValue = Document> = (\n  key: TKey,\n  reducedValue: TValue\n) => TValue;\n\n/** @public */\nexport interface MapReduceOptions<TKey = ObjectId, TValue = Document>\n  extends CommandOperationOptions {\n  /** Sets the output target for the map reduce job. */\n  out?: 'inline' | { inline: 1 } | { replace: string } | { merge: string } | { reduce: string };\n  /** Query filter object. */\n  query?: Document;\n  /** Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces. */\n  sort?: Sort;\n  /** Number of objects to return from collection. */\n  limit?: number;\n  /** Keep temporary data. */\n  keeptemp?: boolean;\n  /** Finalize function. */\n  finalize?: FinalizeFunction<TKey, TValue> | string;\n  /** Can pass in variables that can be access from map/reduce/finalize. */\n  scope?: Document;\n  /** It is possible to make the execution stay in JS. Provided in MongoDB \\> 2.0.X. */\n  jsMode?: boolean;\n  /** Provide statistics on job execution time. */\n  verbose?: boolean;\n  /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */\n  bypassDocumentValidation?: boolean;\n}\n\ninterface MapReduceStats {\n  processtime?: number;\n  counts?: number;\n  timing?: number;\n}\n\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\nexport class MapReduceOperation extends CommandOperation<Document | Document[]> {\n  override options: MapReduceOptions;\n  collection: Collection;\n  /** The mapping function. */\n  map: MapFunction | string;\n  /** The reduce function. */\n  reduce: ReduceFunction | string;\n\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param collection - Collection instance.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  constructor(\n    collection: Collection,\n    map: MapFunction | string,\n    reduce: ReduceFunction | string,\n    options?: MapReduceOptions\n  ) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document | Document[]>\n  ): void {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n\n    const mapCommandHash: Document = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    };\n\n    if (options.scope) {\n      mapCommandHash.scope = processScope(options.scope);\n    }\n\n    // Add any other options passed in\n    for (const n in options) {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) === -1) {\n        mapCommandHash[n] = (options as any)[n];\n      }\n    }\n\n    options = Object.assign({}, options);\n\n    // If we have a read preference and inline is not set as output fail hard\n    if (\n      this.readPreference.mode === ReadPreferenceMode.primary &&\n      options.out &&\n      (options.out as any).inline !== 1 &&\n      options.out !== 'inline'\n    ) {\n      // Force readPreference to primary\n      options.readPreference = ReadPreference.primary;\n      // Decorate command with writeConcern if supported\n      applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options);\n    } else {\n      decorateWithReadConcern(mapCommandHash, coll, options);\n    }\n\n    // Is bypassDocumentValidation specified\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    // Have we specified collation\n    try {\n      decorateWithCollation(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err);\n    }\n\n    if (this.explain && maxWireVersion(server) < 9) {\n      callback(\n        new MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`)\n      );\n      return;\n    }\n\n    // Execute command\n    super.executeCommand(server, session, mapCommandHash, (err, result) => {\n      if (err) return callback(err);\n      // Check if we have an error\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return callback(new MongoServerError(result));\n      }\n\n      // If an explain option was executed, don't process the server results\n      if (this.explain) return callback(undefined, result);\n\n      // Create statistics value\n      const stats: MapReduceStats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing;\n\n      // invoked with inline?\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(undefined, result.results);\n        }\n\n        return callback(undefined, { results: result.results, stats: stats });\n      }\n\n      // The returned collection\n      let collection = null;\n\n      // If we have an object it's a different db\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result;\n        // Return a collection from another db\n        collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      }\n\n      // If we wish for no verbosity\n      if (options['verbose'] == null || !options['verbose']) {\n        return callback(err, collection);\n      }\n\n      // Return stats as third set of values\n      callback(err, { collection, stats });\n    });\n  }\n}\n\n/** Functions that are passed as scope args must be converted to Code instances. */\nfunction processScope(scope: Document | ObjectId) {\n  if (!isObject(scope) || (scope as any)._bsontype === 'ObjectID') {\n    return scope;\n  }\n\n  const newScope: Document = {};\n\n  for (const key of Object.keys(scope)) {\n    if ('function' === typeof (scope as Document)[key]) {\n      newScope[key] = new Code(String((scope as Document)[key]));\n    } else if ((scope as Document)[key]._bsontype === 'Code') {\n      newScope[key] = (scope as Document)[key];\n    } else {\n      newScope[key] = processScope((scope as Document)[key]);\n    }\n  }\n\n  return newScope;\n}\n\ndefineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);\n"]},"metadata":{},"sourceType":"script"}