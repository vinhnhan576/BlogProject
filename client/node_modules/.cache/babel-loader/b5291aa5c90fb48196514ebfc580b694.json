{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nclass DropCollectionOperation extends command_1.CommandOperation {\n  constructor(db, name) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    (async () => {\n      var _a, _b, _c, _d;\n\n      const db = this.db;\n      const options = this.options;\n      const name = this.name;\n      const encryptedFieldsMap = (_a = db.s.client.options.autoEncryption) === null || _a === void 0 ? void 0 : _a.encryptedFieldsMap;\n      let encryptedFields = (_b = options.encryptedFields) !== null && _b !== void 0 ? _b : encryptedFieldsMap === null || encryptedFieldsMap === void 0 ? void 0 : encryptedFieldsMap[`${db.databaseName}.${name}`];\n\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configured with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = await db.listCollections({\n          name\n        }, {\n          nameOnly: false\n        }).toArray();\n        encryptedFields = (_d = (_c = listCollectionsResult === null || listCollectionsResult === void 0 ? void 0 : listCollectionsResult[0]) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.encryptedFields;\n      }\n\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n\n          try {\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n              throw err;\n            }\n          }\n        }\n      }\n\n      return this.executeWithoutEncryptedFieldsCheck(server, session);\n    })().then(result => callback(undefined, result), err => callback(err));\n  }\n\n  executeWithoutEncryptedFieldsCheck(server, session) {\n    return new Promise((resolve, reject) => {\n      super.executeCommand(server, session, {\n        drop: this.name\n      }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n\n}\n\nexports.DropCollectionOperation = DropCollectionOperation;\n/** @internal */\n\nclass DropDatabaseOperation extends command_1.CommandOperation {\n  constructor(db, options) {\n    super(db, options);\n    this.options = options;\n  }\n\n  execute(server, session, callback) {\n    super.executeCommand(server, session, {\n      dropDatabase: 1\n    }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n\n}\n\nexports.DropDatabaseOperation = DropDatabaseOperation;\n(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":"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","names":["DropCollectionOperation","command_1","constructor","db","name","options","execute","server","session","callback","encryptedFieldsMap","s","client","autoEncryption","_a","encryptedFields","_b","databaseName","listCollectionsResult","listCollections","nameOnly","toArray","_c","_d","escCollection","eccCollection","ecocCollection","collectionName","dropOp","executeWithoutEncryptedFieldsCheck","err","error_1","code","NamespaceNotFound","then","result","undefined","Promise","resolve","reject","executeCommand","drop","ok","exports","DropDatabaseOperation","dropDatabase","operation_1","WRITE_OPERATION"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\operations\\drop.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Db } from '../db';\nimport { MONGODB_ERROR_CODES, MongoServerError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Callback } from '../utils';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface DropCollectionOptions extends CommandOperationOptions {\n  /** @experimental */\n  encryptedFields?: Document;\n}\n\n/** @internal */\nexport class DropCollectionOperation extends CommandOperation<boolean> {\n  override options: DropCollectionOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options: DropCollectionOptions = {}) {\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    (async () => {\n      const db = this.db;\n      const options = this.options;\n      const name = this.name;\n\n      const encryptedFieldsMap = db.s.client.options.autoEncryption?.encryptedFieldsMap;\n      let encryptedFields: Document | undefined =\n        options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configured with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = await db\n          .listCollections({ name }, { nameOnly: false })\n          .toArray();\n        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n      }\n\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n          try {\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (\n              !(err instanceof MongoServerError) ||\n              err.code !== MONGODB_ERROR_CODES.NamespaceNotFound\n            ) {\n              throw err;\n            }\n          }\n        }\n      }\n\n      return this.executeWithoutEncryptedFieldsCheck(server, session);\n    })().then(\n      result => callback(undefined, result),\n      err => callback(err)\n    );\n  }\n\n  private executeWithoutEncryptedFieldsCheck(\n    server: Server,\n    session: ClientSession | undefined\n  ): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      super.executeCommand(server, session, { drop: this.name }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n}\n\n/** @public */\nexport type DropDatabaseOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropDatabaseOperation extends CommandOperation<boolean> {\n  override options: DropDatabaseOptions;\n\n  constructor(db: Db, options: DropDatabaseOptions) {\n    super(db, options);\n    this.options = options;\n  }\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    super.executeCommand(server, session, { dropDatabase: 1 }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n}\n\ndefineAspects(DropCollectionOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropDatabaseOperation, [Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}