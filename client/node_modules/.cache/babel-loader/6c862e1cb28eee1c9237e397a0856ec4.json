{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst common_functions_1 = require(\"./common_functions\");\n\nconst operation_1 = require(\"./operation\");\n\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version', // text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes\n'2dsphereIndexVersion', // 2d indexes\n'bits', 'min', 'max', // geoHaystack Indexes\n'bucketSize', // wildcard indexes\n'wildcardProjection']);\n\nfunction isIndexDirection(x) {\n  return typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack';\n}\n\nfunction isSingleIndexTuple(t) {\n  return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);\n}\n\nfunction makeIndexSpec(indexSpec, options) {\n  var _a;\n\n  const key = new Map();\n  const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec; // Iterate through array and handle different types\n\n  for (const spec of indexSpecs) {\n    if (typeof spec === 'string') {\n      key.set(spec, 1);\n    } else if (Array.isArray(spec)) {\n      key.set(spec[0], (_a = spec[1]) !== null && _a !== void 0 ? _a : 1);\n    } else if (spec instanceof Map) {\n      for (const [property, value] of spec) {\n        key.set(property, value);\n      }\n    } else if ((0, utils_1.isObject)(spec)) {\n      for (const [property, value] of Object.entries(spec)) {\n        key.set(property, value);\n      }\n    }\n  }\n\n  return { ...options,\n    key\n  };\n}\n/** @internal */\n\n\nclass IndexesOperation extends operation_1.AbstractOperation {\n  constructor(collection, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = this.options;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {\n      full: true,\n      ...options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\n\nclass CreateIndexesOperation extends command_1.CommandOperation {\n  constructor(parent, collectionName, indexes, options) {\n    super(parent, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionName = collectionName;\n    this.indexes = indexes.map(userIndex => {\n      // Ensure the key is a Map to preserve index key ordering\n      const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));\n      const name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join('_');\n      const validIndexOptions = Object.fromEntries(Object.entries({ ...userIndex\n      }).filter(_ref => {\n        let [optionName] = _ref;\n        return VALID_INDEX_OPTIONS.has(optionName);\n      }));\n      return { ...validIndexOptions,\n        name,\n        key\n      };\n    });\n  }\n\n  execute(server, session, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const cmd = {\n      createIndexes: this.collectionName,\n      indexes\n    };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n\n      cmd.commitQuorum = options.commitQuorum;\n    } // collation is set on each index, it should not be defined at the root\n\n\n    this.options.collation = undefined;\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames);\n    });\n  }\n\n}\n\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\n\nclass CreateIndexOperation extends CreateIndexesOperation {\n  constructor(parent, collectionName, indexSpec, options) {\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n\n}\n\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\n\nclass EnsureIndexOperation extends CreateIndexOperation {\n  constructor(db, collectionName, indexSpec, options) {\n    super(db, collectionName, indexSpec, options);\n    this.readPreference = read_preference_1.ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n\n  execute(server, session, callback) {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({\n      session\n    });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n\n      super.execute(server, session, callback);\n    });\n  }\n\n}\n\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\n\nclass DropIndexOperation extends command_1.CommandOperation {\n  constructor(collection, indexName, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n\n  execute(server, session, callback) {\n    const cmd = {\n      dropIndexes: this.collection.collectionName,\n      index: this.indexName\n    };\n    super.executeCommand(server, session, cmd, callback);\n  }\n\n}\n\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\n\nclass DropIndexesOperation extends DropIndexOperation {\n  constructor(collection, options) {\n    super(collection, '*', options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n\n}\n\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\n\nclass ListIndexesOperation extends command_1.CommandOperation {\n  constructor(collection, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n\n  execute(server, session, callback) {\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const cursor = this.options.batchSize ? {\n      batchSize: this.options.batchSize\n    } : {};\n    const command = {\n      listIndexes: this.collectionNamespace.collection,\n      cursor\n    }; // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n    if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @internal */\n\nclass IndexExistsOperation extends operation_1.AbstractOperation {\n  constructor(collection, indexes, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const indexes = this.indexes;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, (err, indexInformation) => {\n      // If we have an error return\n      if (err != null) return callback(err); // Let's check for the index names\n\n      if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null); // Check in list of indexes\n\n      for (let i = 0; i < indexes.length; i++) {\n        if (indexInformation[indexes[i]] == null) {\n          return callback(undefined, false);\n        }\n      } // All keys found return true\n\n\n      return callback(undefined, true);\n    });\n  }\n\n}\n\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\n\nclass IndexInformationOperation extends operation_1.AbstractOperation {\n  constructor(db, name, options) {\n    super(options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.db = db;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    const db = this.db;\n    const name = this.name;\n    (0, common_functions_1.indexInformation)(db, name, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexInformationOperation = IndexInformationOperation;\n(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);\n(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":"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","names":["VALID_INDEX_OPTIONS","Set","isIndexDirection","x","isSingleIndexTuple","t","Array","isArray","length","makeIndexSpec","indexSpec","options","key","Map","indexSpecs","spec","set","_a","property","value","Object","entries","IndexesOperation","operation_1","constructor","collection","execute","server","session","callback","coll","s","db","collectionName","full","readPreference","exports","CreateIndexesOperation","command_1","parent","indexes","map","userIndex","name","from","flat","join","validIndexOptions","fromEntries","filter","optionName","has","serverWireVersion","cmd","createIndexes","commitQuorum","error_1","collation","undefined","executeCommand","err","indexNames","index","CreateIndexOperation","EnsureIndexOperation","read_preference_1","primary","indexName","cursor","listIndexes","toArray","code","NamespaceNotFound","some","DropIndexOperation","dropIndexes","DropIndexesOperation","ListIndexesOperation","collectionNamespace","namespace","batchSize","command","comment","IndexExistsOperation","indexInformation","i","IndexInformationOperation","READ_OPERATION","RETRYABLE","CURSOR_CREATING","WRITE_OPERATION"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\operations\\indexes.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport type { Db } from '../db';\nimport { MongoCompatibilityError, MONGODB_ERROR_CODES, MongoServerError } from '../error';\nimport type { OneOrMore } from '../mongo_types';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { Callback, isObject, maxWireVersion, MongoDBNamespace } from '../utils';\nimport {\n  CollationOptions,\n  CommandOperation,\n  CommandOperationOptions,\n  OperationParent\n} from './command';\nimport { indexInformation, IndexInformationOptions } from './common_functions';\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\n\nconst VALID_INDEX_OPTIONS = new Set([\n  'background',\n  'unique',\n  'name',\n  'partialFilterExpression',\n  'sparse',\n  'hidden',\n  'expireAfterSeconds',\n  'storageEngine',\n  'collation',\n  'version',\n\n  // text indexes\n  'weights',\n  'default_language',\n  'language_override',\n  'textIndexVersion',\n\n  // 2d-sphere indexes\n  '2dsphereIndexVersion',\n\n  // 2d indexes\n  'bits',\n  'min',\n  'max',\n\n  // geoHaystack Indexes\n  'bucketSize',\n\n  // wildcard indexes\n  'wildcardProjection'\n]);\n\n/** @public */\nexport type IndexDirection =\n  | -1\n  | 1\n  | '2d'\n  | '2dsphere'\n  | 'text'\n  | 'geoHaystack'\n  | 'hashed'\n  | number;\n\nfunction isIndexDirection(x: unknown): x is IndexDirection {\n  return (\n    typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack'\n  );\n}\n/** @public */\nexport type IndexSpecification = OneOrMore<\n  | string\n  | [string, IndexDirection]\n  | { [key: string]: IndexDirection }\n  | Map<string, IndexDirection>\n>;\n\n/** @public */\nexport interface IndexDescription\n  extends Pick<\n    CreateIndexesOptions,\n    | 'background'\n    | 'unique'\n    | 'partialFilterExpression'\n    | 'sparse'\n    | 'hidden'\n    | 'expireAfterSeconds'\n    | 'storageEngine'\n    | 'version'\n    | 'weights'\n    | 'default_language'\n    | 'language_override'\n    | 'textIndexVersion'\n    | '2dsphereIndexVersion'\n    | 'bits'\n    | 'min'\n    | 'max'\n    | 'bucketSize'\n    | 'wildcardProjection'\n  > {\n  collation?: CollationOptions;\n  name?: string;\n  key: { [key: string]: IndexDirection } | Map<string, IndexDirection>;\n}\n\n/** @public */\nexport interface CreateIndexesOptions extends CommandOperationOptions {\n  /** Creates the index in the background, yielding whenever possible. */\n  background?: boolean;\n  /** Creates an unique index. */\n  unique?: boolean;\n  /** Override the autogenerated index name (useful if the resulting name is larger than 128 bytes) */\n  name?: string;\n  /** Creates a partial index based on the given filter object (MongoDB 3.2 or higher) */\n  partialFilterExpression?: Document;\n  /** Creates a sparse index. */\n  sparse?: boolean;\n  /** Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher) */\n  expireAfterSeconds?: number;\n  /** Allows users to configure the storage engine on a per-index basis when creating an index. (MongoDB 3.0 or higher) */\n  storageEngine?: Document;\n  /** (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes. */\n  commitQuorum?: number | string;\n  /** Specifies the index version number, either 0 or 1. */\n  version?: number;\n  // text indexes\n  weights?: Document;\n  default_language?: string;\n  language_override?: string;\n  textIndexVersion?: number;\n  // 2d-sphere indexes\n  '2dsphereIndexVersion'?: number;\n  // 2d indexes\n  bits?: number;\n  /** For geospatial indexes set the lower bound for the co-ordinates. */\n  min?: number;\n  /** For geospatial indexes set the high bound for the co-ordinates. */\n  max?: number;\n  // geoHaystack Indexes\n  bucketSize?: number;\n  // wildcard indexes\n  wildcardProjection?: Document;\n  /** Specifies that the index should exist on the target collection but should not be used by the query planner when executing operations. (MongoDB 4.4 or higher) */\n  hidden?: boolean;\n}\n\nfunction isSingleIndexTuple(t: unknown): t is [string, IndexDirection] {\n  return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);\n}\n\nfunction makeIndexSpec(\n  indexSpec: IndexSpecification,\n  options?: CreateIndexesOptions\n): IndexDescription {\n  const key: Map<string, IndexDirection> = new Map();\n\n  const indexSpecs =\n    !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;\n\n  // Iterate through array and handle different types\n  for (const spec of indexSpecs) {\n    if (typeof spec === 'string') {\n      key.set(spec, 1);\n    } else if (Array.isArray(spec)) {\n      key.set(spec[0], spec[1] ?? 1);\n    } else if (spec instanceof Map) {\n      for (const [property, value] of spec) {\n        key.set(property, value);\n      }\n    } else if (isObject(spec)) {\n      for (const [property, value] of Object.entries(spec)) {\n        key.set(property, value);\n      }\n    }\n  }\n\n  return { ...options, key };\n}\n\n/** @internal */\nexport class IndexesOperation extends AbstractOperation<Document[]> {\n  override options: IndexInformationOptions;\n  collection: Collection;\n\n  constructor(collection: Collection, options: IndexInformationOptions) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document[]>\n  ): void {\n    const coll = this.collection;\n    const options = this.options;\n\n    indexInformation(\n      coll.s.db,\n      coll.collectionName,\n      { full: true, ...options, readPreference: this.readPreference, session },\n      callback\n    );\n  }\n}\n\n/** @internal */\nexport class CreateIndexesOperation<\n  T extends string | string[] = string[]\n> extends CommandOperation<T> {\n  override options: CreateIndexesOptions;\n  collectionName: string;\n  indexes: ReadonlyArray<Omit<IndexDescription, 'key'> & { key: Map<string, IndexDirection> }>;\n\n  constructor(\n    parent: OperationParent,\n    collectionName: string,\n    indexes: IndexDescription[],\n    options?: CreateIndexesOptions\n  ) {\n    super(parent, options);\n\n    this.options = options ?? {};\n    this.collectionName = collectionName;\n    this.indexes = indexes.map(userIndex => {\n      // Ensure the key is a Map to preserve index key ordering\n      const key =\n        userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));\n      const name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join('_');\n      const validIndexOptions = Object.fromEntries(\n        Object.entries({ ...userIndex }).filter(([optionName]) =>\n          VALID_INDEX_OPTIONS.has(optionName)\n        )\n      );\n      return {\n        ...validIndexOptions,\n        name,\n        key\n      };\n    });\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<T>\n  ): void {\n    const options = this.options;\n    const indexes = this.indexes;\n\n    const serverWireVersion = maxWireVersion(server);\n\n    const cmd: Document = { createIndexes: this.collectionName, indexes };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(\n          new MongoCompatibilityError(\n            'Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'\n          )\n        );\n        return;\n      }\n      cmd.commitQuorum = options.commitQuorum;\n    }\n\n    // collation is set on each index, it should not be defined at the root\n    this.options.collation = undefined;\n\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames as T);\n    });\n  }\n}\n\n/** @internal */\nexport class CreateIndexOperation extends CreateIndexesOperation<string> {\n  constructor(\n    parent: OperationParent,\n    collectionName: string,\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions\n  ) {\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<string>\n  ): void {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n}\n\n/** @internal */\nexport class EnsureIndexOperation extends CreateIndexOperation {\n  db: Db;\n\n  constructor(\n    db: Db,\n    collectionName: string,\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions\n  ) {\n    super(db, collectionName, indexSpec, options);\n\n    this.readPreference = ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n\n  override execute(server: Server, session: ClientSession | undefined, callback: Callback): void {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({ session });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && (err as MongoServerError).code !== MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n\n      super.execute(server, session, callback);\n    });\n  }\n}\n\n/** @public */\nexport type DropIndexesOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropIndexOperation extends CommandOperation<Document> {\n  override options: DropIndexesOptions;\n  collection: Collection;\n  indexName: string;\n\n  constructor(collection: Collection, indexName: string, options?: DropIndexesOptions) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document>\n  ): void {\n    const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };\n    super.executeCommand(server, session, cmd, callback);\n  }\n}\n\n/** @internal */\nexport class DropIndexesOperation extends DropIndexOperation {\n  constructor(collection: Collection, options: DropIndexesOptions) {\n    super(collection, '*', options);\n  }\n\n  override execute(server: Server, session: ClientSession | undefined, callback: Callback): void {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n}\n\n/** @public */\nexport interface ListIndexesOptions extends CommandOperationOptions {\n  /** The batchSize for the returned command cursor or if pre 2.8 the systems batch collection */\n  batchSize?: number;\n}\n\n/** @internal */\nexport class ListIndexesOperation extends CommandOperation<Document> {\n  override options: ListIndexesOptions;\n  collectionNamespace: MongoDBNamespace;\n\n  constructor(collection: Collection, options?: ListIndexesOptions) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document>\n  ): void {\n    const serverWireVersion = maxWireVersion(server);\n\n    const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};\n\n    const command: Document = { listIndexes: this.collectionNamespace.collection, cursor };\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n}\n\n/** @internal */\nexport class IndexExistsOperation extends AbstractOperation<boolean> {\n  override options: IndexInformationOptions;\n  collection: Collection;\n  indexes: string | string[];\n\n  constructor(\n    collection: Collection,\n    indexes: string | string[],\n    options: IndexInformationOptions\n  ) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    const coll = this.collection;\n    const indexes = this.indexes;\n\n    indexInformation(\n      coll.s.db,\n      coll.collectionName,\n      { ...this.options, readPreference: this.readPreference, session },\n      (err, indexInformation) => {\n        // If we have an error return\n        if (err != null) return callback(err);\n        // Let's check for the index names\n        if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null);\n        // Check in list of indexes\n        for (let i = 0; i < indexes.length; i++) {\n          if (indexInformation[indexes[i]] == null) {\n            return callback(undefined, false);\n          }\n        }\n\n        // All keys found return true\n        return callback(undefined, true);\n      }\n    );\n  }\n}\n\n/** @internal */\nexport class IndexInformationOperation extends AbstractOperation<Document> {\n  override options: IndexInformationOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options?: IndexInformationOptions) {\n    super(options);\n    this.options = options ?? {};\n    this.db = db;\n    this.name = name;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document>\n  ): void {\n    const db = this.db;\n    const name = this.name;\n\n    indexInformation(\n      db,\n      name,\n      { ...this.options, readPreference: this.readPreference, session },\n      callback\n    );\n  }\n}\n\ndefineAspects(ListIndexesOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.CURSOR_CREATING\n]);\ndefineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(CreateIndexOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(EnsureIndexOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropIndexOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropIndexesOperation, [Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}