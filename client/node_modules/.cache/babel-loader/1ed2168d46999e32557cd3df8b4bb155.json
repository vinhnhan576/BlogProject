{"ast":null,"code":"\"use strict\";\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\n\nconst util_1 = require(\"util\");\n\nconst bson_1 = require(\"./bson\");\n\nconst metrics_1 = require(\"./cmap/metrics\");\n\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\n\nconst constants_1 = require(\"./constants\");\n\nconst error_1 = require(\"./error\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst run_command_1 = require(\"./operations/run_command\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst transactions_1 = require(\"./transactions\");\n\nconst utils_1 = require(\"./utils\");\n\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\n\nconst kServerSession = Symbol('serverSession');\n/** @internal */\n\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\n\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\n\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\n\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\n\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(client, sessionPool, options, clientOptions) {\n    var _b;\n\n    super();\n    /** @internal */\n\n    this[_a] = false;\n\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options !== null && options !== void 0 ? options : {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: (_b = options.causalConsistency) !== null && _b !== void 0 ? _b : defaultCausalConsistencyValue\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n\n\n  get id() {\n    var _b;\n\n    return (_b = this[kServerSession]) === null || _b === void 0 ? void 0 : _b.id;\n  }\n\n  get serverSession() {\n    let serverSession = this[kServerSession];\n\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n\n      if (this.hasEnded) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n\n    return serverSession;\n  }\n  /** Whether or not this session is configured for snapshot reads */\n\n\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced() {\n    var _b;\n\n    return ((_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.description.type) === common_1.TopologyType.LoadBalanced;\n  }\n  /** @internal */\n\n\n  get pinnedConnection() {\n    return this[kPinnedConnection];\n  }\n  /** @internal */\n\n\n  pin(conn) {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n  }\n  /** @internal */\n\n\n  unpin(options) {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned() {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n\n  endSession(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    const finalOptions = {\n      force: true,\n      ...options\n    };\n    return (0, utils_1.maybeCallback)(async () => {\n      try {\n        if (this.inTransaction()) {\n          await this.abortTransaction();\n        }\n\n        if (!this.hasEnded) {\n          const serverSession = this[kServerSession];\n\n          if (serverSession != null) {\n            // release the server session back to the pool\n            this.sessionPool.release(serverSession); // Make sure a new serverSession never makes it onto this ClientSession\n\n            Object.defineProperty(this, kServerSession, {\n              value: ServerSession.clone(serverSession),\n              writable: false\n            });\n          } // mark the session as ended, and emit a signal\n\n\n          this.hasEnded = true;\n          this.emit('ended', this);\n        }\n      } catch {// spec indicates that we should ignore all errors for `endSessions`\n      } finally {\n        maybeClearPinnedConnection(this, finalOptions);\n      }\n    }, callback);\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n\n\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n\n\n  advanceClusterTime(clusterTime) {\n    var _b, _c;\n\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n    }\n\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n    }\n\n    if (!clusterTime.signature || ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'number' && ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long' // apparently we decode the key to number?\n    ) {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n    }\n\n    (0, common_1._advanceClusterTime)(this, clusterTime);\n  }\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n\n\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n\n\n  incrementTransactionNumber() {\n    this[kTxnNumberIncrement] += 1;\n  }\n  /** @returns whether this session is currently in a transaction or not */\n\n\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n\n\n  startTransaction(options) {\n    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n\n    if (this.inTransaction()) {\n      throw new error_1.MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n\n    if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    } // increment txnNumber\n\n\n    this.incrementTransactionNumber(); // create transaction state\n\n    this.transaction = new transactions_1.Transaction({\n      readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,\n      writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,\n      readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,\n      maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n\n  commitTransaction(callback) {\n    return (0, utils_1.maybeCallback)(async () => endTransactionAsync(this, 'commitTransaction'), callback);\n  }\n\n  abortTransaction(callback) {\n    return (0, utils_1.maybeCallback)(async () => endTransactionAsync(this, 'abortTransaction'), callback);\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n\n\n  toBSON() {\n    throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * Runs a provided callback within a transaction, retrying either the commitTransaction operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n   * Any callbacks that do not return a Promise will result in undefined behavior.\n   *\n   * @remarks\n   * This function:\n   * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)\n   * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`\n   * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/developer/quickstart/node-transactions/\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n\n\n  withTransaction(fn, options) {\n    const startTime = (0, utils_1.now)();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n\n}\n\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\n\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\n\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n    return;\n  }\n\n  const topology = session.client.topology; // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {\n      loadBalancer.s.pool.checkIn(conn);\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n\n      if (options === null || options === void 0 ? void 0 : options.forceClear) {\n        loadBalancer.s.pool.clear({\n          serviceId: conn.serviceId\n        });\n      }\n    }\n\n    session[kPinnedConnection] = undefined;\n  }\n}\n\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\n\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  var _b;\n\n  session.startTransaction(options);\n  let promise;\n\n  try {\n    promise = fn(session);\n  } catch (err) {\n    const PromiseConstructor = (_b = promise_provider_1.PromiseProvider.get()) !== null && _b !== void 0 ? _b : Promise;\n    promise = PromiseConstructor.reject(err);\n  }\n\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    session.abortTransaction().catch(() => null);\n    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }, err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n      }\n\n      throw err;\n    }\n\n    if (session.inTransaction()) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n\n    return maybeRetryOrThrow(err);\n  });\n}\n\nconst endTransactionAsync = (0, util_1.promisify)(endTransaction);\n\nfunction endTransaction(session, commandName, callback) {\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  } // construct and send the command\n\n\n  const command = {\n    [commandName]: 1\n  }; // apply a writeConcern if specified\n\n  let writeConcern;\n\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n\n  function commandHandler(error, result) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      } // The spec indicates that we should ignore all errors on `abortTransaction`\n\n\n      return callback();\n    }\n\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n\n    if (error instanceof error_1.MongoError) {\n      if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {\n        if (isUnknownTransactionCommitResult(error)) {\n          error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult); // per txns spec, must unpin session in this case\n\n          session.unpin({\n            error\n          });\n        }\n      } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        session.unpin({\n          error\n        });\n      }\n    }\n\n    callback(error, result);\n  }\n\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  } // send the command\n\n\n  (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n    session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), (error, result) => {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n\n    if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), commandHandler);\n    }\n\n    commandHandler(error, result);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\n\n\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n\n\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n\n\n  static clone(serverSession) {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n    const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type); // Manual prototype construction to avoid modifying the constructor of this class\n\n    return Object.setPrototypeOf({\n      id: {\n        id\n      },\n      lastUse: serverSession.lastUse,\n      txnNumber: serverSession.txnNumber,\n      isDirty: serverSession.isDirty\n    }, ServerSession.prototype);\n  }\n\n}\n\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\n\nclass ServerSessionPool {\n  constructor(client) {\n    if (client == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n\n    this.client = client;\n    this.sessions = new utils_1.List();\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n\n\n  acquire() {\n    var _b, _c, _d;\n\n    const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;\n    let session = null; // Try to obtain from session pool\n\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n\n      if (potentialSession != null && (!!((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n        session = potentialSession;\n        break;\n      }\n    } // If nothing valid came from the pool make a new one\n\n\n    if (session == null) {\n      session = new ServerSession();\n    }\n\n    return session;\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n\n\n  release(session) {\n    var _b, _c, _d;\n\n    const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;\n\n    if (((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      } // otherwise, readd this session to the session pool\n\n\n      this.sessions.unshift(session);\n    }\n  }\n\n}\n\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\n\nfunction applySession(session, command, options) {\n  var _b, _c;\n\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  } // May acquire serverSession here\n\n\n  const serverSession = session.serverSession;\n\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  }\n\n  if (((_b = options.writeConcern) === null || _b === void 0 ? void 0 : _b.w) === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n\n    return;\n  } // mark the last use of this session, and apply the `lsid`\n\n\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id;\n  const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0; // TODO(NODE-2674): Preserve int64 sent from MongoDB\n\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command, options)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n\n    return;\n  } // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || ((_c = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _c === void 0 ? void 0 : _c.readConcern);\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n\n  return;\n}\n\nexports.applySession = applySession;\n\nfunction updateSessionFromResponse(session, document) {\n  var _b;\n\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;\n\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"mappings":"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","names":["minWireVersionForShardedTransactions","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","kPinnedConnection","kTxnNumberIncrement","ClientSession","mongo_types_1","constructor","client","sessionPool","options","clientOptions","error_1","ServerSessionPool","snapshot","causalConsistency","hasEnded","explicit","acquire","defaultCausalConsistencyValue","supports","_b","clusterTime","initialClusterTime","operationTime","undefined","owner","defaultTransactionOptions","Object","assign","transaction","transactions_1","id","serverSession","snapshotEnabled","loadBalanced","topology","description","type","common_1","LoadBalanced","pinnedConnection","pin","conn","TypeError","emit","constants_1","inTransaction","metrics_1","TXN","CURSOR","unpin","maybeClearPinnedConnection","unpinServer","isPinned","endSession","callback","finalOptions","force","abortTransaction","release","defineProperty","value","ServerSession","clone","writable","advanceOperationTime","greaterThan","advanceClusterTime","_bsontype","signature","hash","keyId","_c","equals","session","buffer","incrementTransactionNumber","isActive","startTransaction","isCommitted","topologyMaxWireVersion","readConcern","_d","writeConcern","_e","_f","_g","readPreference","_h","_j","_k","maxCommitTimeMS","_l","transition","STARTING_TRANSACTION","commitTransaction","endTransactionAsync","toBSON","withTransaction","fn","startTime","attemptTransaction","exports","MAX_WITH_TRANSACTION_TIMEOUT","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","isUnknownTransactionCommitResult","err","isNonDeterministicWriteConcernError","codeName","has","isMaxTimeMSExpiredError","code","UnsatisfiableWriteConcern","UnknownReplWriteConcern","error","hasErrorLabel","TransientTransactionError","servers","Array","from","s","values","loadBalancer","pool","checkIn","state","NO_TRANSACTION","forceClear","clear","serviceId","MaxTimeMSExpired","writeConcernError","attemptTransactionCommit","catch","UnknownTransactionCommitResult","USER_EXPLICIT_TXN_END_STATES","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","promise","PromiseConstructor","get","Promise","reject","then","maybeRetryOrThrow","addErrorLabel","endTransaction","commandName","txnState","TRANSACTION_COMMITTED_EMPTY","command","w","wtimeout","maxTimeMS","commandHandler","result","RetryableWriteError","recoveryToken","run_command_1","read_preference_1","primary","bypassPinningCheck","bson_1","SUBTYPE_UUID","lastUse","txnNumber","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","arrayBuffer","ArrayBuffer","idBytes","Buffer","set","sub_type","setPrototypeOf","prototype","sessions","utils_1","logicalSessionTimeoutMinutes","length","potentialSession","shift","unshift","prune","applySession","lsid","inTxnOrTxnCommand","isRetryableWrite","willRetryWrite","fromNumber","afterClusterTime","level","read_concern_1","atClusterTime","autocommit","TRANSACTION_IN_PROGRESS","updateSessionFromResponse","document","$clusterTime","_recoveryToken","cursor"],"sources":["D:\\Code\\HTML\\BlogProject\\node_modules\\mongodb\\src\\sessions.ts"],"sourcesContent":["import { promisify } from 'util';\n\nimport { Binary, Document, Long, Timestamp } from './bson';\nimport type { CommandOptions, Connection } from './cmap/connection';\nimport { ConnectionPoolMetrics } from './cmap/metrics';\nimport { isSharded } from './cmap/wire_protocol/shared';\nimport { PINNED, UNPINNED } from './constants';\nimport type { AbstractCursor } from './cursor/abstract_cursor';\nimport {\n  AnyError,\n  MongoAPIError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoDriverError,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoWriteConcernError\n} from './error';\nimport type { MongoClient, MongoOptions } from './mongo_client';\nimport { TypedEventEmitter } from './mongo_types';\nimport { executeOperation } from './operations/execute_operation';\nimport { RunAdminCommandOperation } from './operations/run_command';\nimport { PromiseProvider } from './promise_provider';\nimport { ReadConcernLevel } from './read_concern';\nimport { ReadPreference } from './read_preference';\nimport { _advanceClusterTime, ClusterTime, TopologyType } from './sdam/common';\nimport { isTransactionCommand, Transaction, TransactionOptions, TxnState } from './transactions';\nimport {\n  calculateDurationInMs,\n  Callback,\n  commandSupportsReadConcern,\n  isPromiseLike,\n  List,\n  maxWireVersion,\n  maybeCallback,\n  now,\n  uuidV4\n} from './utils';\n\nconst minWireVersionForShardedTransactions = 8;\n\n/** @public */\nexport interface ClientSessionOptions {\n  /** Whether causal consistency should be enabled on this session */\n  causalConsistency?: boolean;\n  /** Whether all read operations should be read from the same snapshot for this session (NOTE: not compatible with `causalConsistency=true`) */\n  snapshot?: boolean;\n  /** The default TransactionOptions to use for transactions started on this session. */\n  defaultTransactionOptions?: TransactionOptions;\n\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  /** @internal */\n  explicit?: boolean;\n  /** @internal */\n  initialClusterTime?: ClusterTime;\n}\n\n/** @public */\nexport type WithTransactionCallback<T = void> = (session: ClientSession) => Promise<T>;\n\n/** @public */\nexport type ClientSessionEvents = {\n  ended(session: ClientSession): void;\n};\n\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n\n/** @public */\nexport interface EndSessionOptions {\n  /**\n   * An optional error which caused the call to end this session\n   * @internal\n   */\n  error?: AnyError;\n  force?: boolean;\n  forceClear?: boolean;\n}\n\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nexport class ClientSession extends TypedEventEmitter<ClientSessionEvents> {\n  /** @internal */\n  client: MongoClient;\n  /** @internal */\n  sessionPool: ServerSessionPool;\n  hasEnded: boolean;\n  clientOptions?: MongoOptions;\n  supports: { causalConsistency: boolean };\n  clusterTime?: ClusterTime;\n  operationTime?: Timestamp;\n  explicit: boolean;\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  defaultTransactionOptions: TransactionOptions;\n  transaction: Transaction;\n  /** @internal */\n  [kServerSession]: ServerSession | null;\n  /** @internal */\n  [kSnapshotTime]?: Timestamp;\n  /** @internal */\n  [kSnapshotEnabled] = false;\n  /** @internal */\n  [kPinnedConnection]?: Connection;\n  /** @internal */\n  [kTxnNumberIncrement]: number;\n\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(\n    client: MongoClient,\n    sessionPool: ServerSessionPool,\n    options: ClientSessionOptions,\n    clientOptions?: MongoOptions\n  ) {\n    super();\n\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options ?? {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new MongoInvalidArgumentError(\n          'Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive'\n        );\n      }\n    }\n\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n    };\n\n    this.clusterTime = options.initialClusterTime;\n\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new Transaction();\n  }\n\n  /** The server id associated with this session */\n  get id(): ServerSessionId | undefined {\n    return this[kServerSession]?.id;\n  }\n\n  get serverSession(): ServerSession {\n    let serverSession = this[kServerSession];\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n      if (this.hasEnded) {\n        throw new MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n    return serverSession;\n  }\n\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled(): boolean {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced(): boolean {\n    return this.client.topology?.description.type === TopologyType.LoadBalanced;\n  }\n\n  /** @internal */\n  get pinnedConnection(): Connection | undefined {\n    return this[kPinnedConnection];\n  }\n\n  /** @internal */\n  pin(conn: Connection): void {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(\n      PINNED,\n      this.inTransaction() ? ConnectionPoolMetrics.TXN : ConnectionPoolMetrics.CURSOR\n    );\n  }\n\n  /** @internal */\n  unpin(options?: { force?: boolean; forceClear?: boolean; error?: AnyError }): void {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned(): boolean {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n\n  /**\n   * Ends this session on the server\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   * @param callback - Optional callback for completion of this operation\n   */\n  endSession(): Promise<void>;\n  endSession(options: EndSessionOptions): Promise<void>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  endSession(callback: Callback<void>): void;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  endSession(options: EndSessionOptions, callback: Callback<void>): void;\n  endSession(\n    options?: EndSessionOptions | Callback<void>,\n    callback?: Callback<void>\n  ): void | Promise<void> {\n    if (typeof options === 'function') (callback = options), (options = {});\n    const finalOptions = { force: true, ...options };\n\n    return maybeCallback(async () => {\n      try {\n        if (this.inTransaction()) {\n          await this.abortTransaction();\n        }\n        if (!this.hasEnded) {\n          const serverSession = this[kServerSession];\n          if (serverSession != null) {\n            // release the server session back to the pool\n            this.sessionPool.release(serverSession);\n            // Make sure a new serverSession never makes it onto this ClientSession\n            Object.defineProperty(this, kServerSession, {\n              value: ServerSession.clone(serverSession),\n              writable: false\n            });\n          }\n          // mark the session as ended, and emit a signal\n          this.hasEnded = true;\n          this.emit('ended', this);\n        }\n      } catch {\n        // spec indicates that we should ignore all errors for `endSessions`\n      } finally {\n        maybeClearPinnedConnection(this, finalOptions);\n      }\n    }, callback);\n  }\n\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime: Timestamp): void {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n  advanceClusterTime(clusterTime: ClusterTime): void {\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new MongoInvalidArgumentError('input cluster time must be an object');\n    }\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new MongoInvalidArgumentError(\n        'input cluster time \"clusterTime\" property must be a valid BSON Timestamp'\n      );\n    }\n    if (\n      !clusterTime.signature ||\n      clusterTime.signature.hash?._bsontype !== 'Binary' ||\n      (typeof clusterTime.signature.keyId !== 'number' &&\n        clusterTime.signature.keyId?._bsontype !== 'Long') // apparently we decode the key to number?\n    ) {\n      throw new MongoInvalidArgumentError(\n        'input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId'\n      );\n    }\n\n    _advanceClusterTime(this, clusterTime);\n  }\n\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session: ClientSession): boolean {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n  incrementTransactionNumber(): void {\n    this[kTxnNumberIncrement] += 1;\n  }\n\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction(): boolean {\n    return this.transaction.isActive;\n  }\n\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options?: TransactionOptions): void {\n    if (this[kSnapshotEnabled]) {\n      throw new MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n\n    if (this.inTransaction()) {\n      throw new MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.client.topology);\n    if (\n      isSharded(this.client.topology) &&\n      topologyMaxWireVersion != null &&\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\n    ) {\n      throw new MongoCompatibilityError(\n        'Transactions are not supported on sharded clusters in MongoDB < 4.2.'\n      );\n    }\n\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new Transaction({\n      readConcern:\n        options?.readConcern ??\n        this.defaultTransactionOptions.readConcern ??\n        this.clientOptions?.readConcern,\n      writeConcern:\n        options?.writeConcern ??\n        this.defaultTransactionOptions.writeConcern ??\n        this.clientOptions?.writeConcern,\n      readPreference:\n        options?.readPreference ??\n        this.defaultTransactionOptions.readPreference ??\n        this.clientOptions?.readPreference,\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n    });\n\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n\n  /**\n   * Commits the currently active transaction in this session.\n   *\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  commitTransaction(): Promise<Document>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  commitTransaction(callback: Callback<Document>): void;\n  commitTransaction(callback?: Callback<Document>): Promise<Document> | void {\n    return maybeCallback(async () => endTransactionAsync(this, 'commitTransaction'), callback);\n  }\n\n  /**\n   * Aborts the currently active transaction in this session.\n   *\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  abortTransaction(): Promise<Document>;\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\n  abortTransaction(callback: Callback<Document>): void;\n  abortTransaction(callback?: Callback<Document>): Promise<Document> | void {\n    return maybeCallback(async () => endTransactionAsync(this, 'abortTransaction'), callback);\n  }\n\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON(): never {\n    throw new MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n\n  /**\n   * Runs a provided callback within a transaction, retrying either the commitTransaction operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n   * Any callbacks that do not return a Promise will result in undefined behavior.\n   *\n   * @remarks\n   * This function:\n   * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)\n   * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`\n   * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/developer/quickstart/node-transactions/\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n  withTransaction<T = void>(\n    fn: WithTransactionCallback<T>,\n    options?: TransactionOptions\n  ): Promise<Document | undefined> {\n    const startTime = now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\n\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n  'CannotSatisfyWriteConcern',\n  'UnknownReplWriteConcern',\n  'UnsatisfiableWriteConcern'\n]);\n\nfunction hasNotTimedOut(startTime: number, max: number) {\n  return calculateDurationInMs(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err: MongoError) {\n  const isNonDeterministicWriteConcernError =\n    err instanceof MongoServerError &&\n    err.codeName &&\n    NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n\n  return (\n    isMaxTimeMSExpiredError(err) ||\n    (!isNonDeterministicWriteConcernError &&\n      err.code !== MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n      err.code !== MONGODB_ERROR_CODES.UnknownReplWriteConcern)\n  );\n}\n\nexport function maybeClearPinnedConnection(\n  session: ClientSession,\n  options?: EndSessionOptions\n): void {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options?.error;\n\n  if (\n    session.inTransaction() &&\n    error &&\n    error instanceof MongoError &&\n    error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)\n  ) {\n    return;\n  }\n\n  const topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if (options?.error == null || options?.force) {\n      loadBalancer.s.pool.checkIn(conn);\n      conn.emit(\n        UNPINNED,\n        session.transaction.state !== TxnState.NO_TRANSACTION\n          ? ConnectionPoolMetrics.TXN\n          : ConnectionPoolMetrics.CURSOR\n      );\n\n      if (options?.forceClear) {\n        loadBalancer.s.pool.clear({ serviceId: conn.serviceId });\n      }\n    }\n\n    session[kPinnedConnection] = undefined;\n  }\n}\n\nfunction isMaxTimeMSExpiredError(err: MongoError) {\n  if (err == null || !(err instanceof MongoServerError)) {\n    return false;\n  }\n\n  return (\n    err.code === MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n    (err.writeConcernError && err.writeConcernError.code === MONGODB_ERROR_CODES.MaxTimeMSExpired)\n  );\n}\n\nfunction attemptTransactionCommit<T>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<T>,\n  options?: TransactionOptions\n): Promise<T> {\n  return session.commitTransaction().catch((err: MongoError) => {\n    if (\n      err instanceof MongoError &&\n      hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n      !isMaxTimeMSExpiredError(err)\n    ) {\n      if (err.hasErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel(MongoErrorLabel.TransientTransactionError)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set<TxnState>([\n  TxnState.NO_TRANSACTION,\n  TxnState.TRANSACTION_COMMITTED,\n  TxnState.TRANSACTION_ABORTED\n]);\n\nfunction userExplicitlyEndedTransaction(session: ClientSession) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction<TSchema>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<TSchema>,\n  options?: TransactionOptions\n): Promise<any> {\n  session.startTransaction(options);\n\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    const PromiseConstructor = PromiseProvider.get() ?? Promise;\n    promise = PromiseConstructor.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction().catch(() => null);\n    throw new MongoInvalidArgumentError(\n      'Function provided to `withTransaction` must return a Promise'\n    );\n  }\n\n  return promise.then(\n    () => {\n      if (userExplicitlyEndedTransaction(session)) {\n        return;\n      }\n\n      return attemptTransactionCommit(session, startTime, fn, options);\n    },\n    err => {\n      function maybeRetryOrThrow(err: MongoError): Promise<any> {\n        if (\n          err instanceof MongoError &&\n          err.hasErrorLabel(MongoErrorLabel.TransientTransactionError) &&\n          hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)\n        ) {\n          return attemptTransaction(session, startTime, fn, options);\n        }\n\n        if (isMaxTimeMSExpiredError(err)) {\n          err.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\n        }\n\n        throw err;\n      }\n\n      if (session.inTransaction()) {\n        return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n      }\n\n      return maybeRetryOrThrow(err);\n    }\n  );\n}\n\nconst endTransactionAsync = promisify(\n  endTransaction as (\n    session: ClientSession,\n    commandName: 'abortTransaction' | 'commitTransaction',\n    callback: (error: Error, result: Document) => void\n  ) => void\n);\n\nfunction endTransaction(\n  session: ClientSession,\n  commandName: 'abortTransaction' | 'commitTransaction',\n  callback: Callback<Document>\n) {\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoTransactionError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (\n      txnState === TxnState.STARTING_TRANSACTION ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(\n        new MongoTransactionError('Cannot call commitTransaction after calling abortTransaction')\n      );\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (\n      txnState === TxnState.TRANSACTION_COMMITTED ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      callback(\n        new MongoTransactionError('Cannot call abortTransaction after calling commitTransaction')\n      );\n      return;\n    }\n  }\n\n  // construct and send the command\n  const command: Document = { [commandName]: 1 };\n\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = { w: session.clientOptions.writeConcern.w };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, { writeConcern });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n  }\n\n  function commandHandler(error?: Error, result?: Document) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, { force: false });\n      }\n\n      // The spec indicates that we should ignore all errors on `abortTransaction`\n      return callback();\n    }\n\n    session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n    if (error instanceof MongoError) {\n      if (\n        error.hasErrorLabel(MongoErrorLabel.RetryableWriteError) ||\n        error instanceof MongoWriteConcernError ||\n        isMaxTimeMSExpiredError(error)\n      ) {\n        if (isUnknownTransactionCommitResult(error)) {\n          error.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\n\n          // per txns spec, must unpin session in this case\n          session.unpin({ error });\n        }\n      } else if (error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)) {\n        session.unpin({ error });\n      }\n    }\n\n    callback(error, result);\n  }\n\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n\n  // send the command\n  executeOperation(\n    session.client,\n    new RunAdminCommandOperation(undefined, command, {\n      session,\n      readPreference: ReadPreference.primary,\n      bypassPinningCheck: true\n    }),\n    (error, result) => {\n      if (command.abortTransaction) {\n        // always unpin on abort regardless of command outcome\n        session.unpin();\n      }\n\n      if (error instanceof MongoError && error.hasErrorLabel(MongoErrorLabel.RetryableWriteError)) {\n        // SPEC-1185: apply majority write concern when retrying commitTransaction\n        if (command.commitTransaction) {\n          // per txns spec, must unpin session in this case\n          session.unpin({ force: true });\n\n          command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n            w: 'majority'\n          });\n        }\n\n        return executeOperation(\n          session.client,\n          new RunAdminCommandOperation(undefined, command, {\n            session,\n            readPreference: ReadPreference.primary,\n            bypassPinningCheck: true\n          }),\n          commandHandler\n        );\n      }\n\n      commandHandler(error, result);\n    }\n  );\n}\n\n/** @public */\nexport type ServerSessionId = { id: Binary };\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nexport class ServerSession {\n  id: ServerSessionId;\n  lastUse: number;\n  txnNumber: number;\n  isDirty: boolean;\n\n  /** @internal */\n  constructor() {\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes: number): boolean {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(\n      ((calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000\n    );\n\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n  static clone(serverSession: ServerSession): Readonly<ServerSession> {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n\n    const id = new Binary(idBytes, serverSession.id.id.sub_type);\n\n    // Manual prototype construction to avoid modifying the constructor of this class\n    return Object.setPrototypeOf(\n      {\n        id: { id },\n        lastUse: serverSession.lastUse,\n        txnNumber: serverSession.txnNumber,\n        isDirty: serverSession.isDirty\n      },\n      ServerSession.prototype\n    );\n  }\n}\n\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nexport class ServerSessionPool {\n  client: MongoClient;\n  sessions: List<ServerSession>;\n\n  constructor(client: MongoClient) {\n    if (client == null) {\n      throw new MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n\n    this.client = client;\n    this.sessions = new List<ServerSession>();\n  }\n\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire(): ServerSession {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n\n    let session: ServerSession | null = null;\n\n    // Try to obtain from session pool\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n      if (\n        potentialSession != null &&\n        (!!this.client.topology?.loadBalanced ||\n          !potentialSession.hasTimedOut(sessionTimeoutMinutes))\n      ) {\n        session = potentialSession;\n        break;\n      }\n    }\n\n    // If nothing valid came from the pool make a new one\n    if (session == null) {\n      session = new ServerSession();\n    }\n\n    return session;\n  }\n\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session: ServerSession): void {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n\n    if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\n\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nexport function applySession(\n  session: ClientSession,\n  command: Document,\n  options: CommandOptions\n): MongoDriverError | undefined {\n  if (session.hasEnded) {\n    return new MongoExpiredSessionError();\n  }\n\n  // May acquire serverSession here\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new MongoRuntimeError('Unable to acquire server session');\n  }\n\n  if (options.writeConcern?.w === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id;\n\n  const inTxnOrTxnCommand = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    }\n\n    if (\n      session.supports.causalConsistency &&\n      session.operationTime &&\n      commandSupportsReadConcern(command, options)\n    ) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || { level: ReadConcernLevel.snapshot };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n      }\n    }\n\n    return;\n  }\n\n  // now attempt to apply transaction-specific sessions data\n\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n\n    const readConcern =\n      session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n  }\n  return;\n}\n\nexport function updateSessionFromResponse(session: ClientSession, document: Document): void {\n  if (document.$clusterTime) {\n    _advanceClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}